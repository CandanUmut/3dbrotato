<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Nova Arena 3D · Rogue Survivor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --panel: rgba(15, 23, 42, 0.94);
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.15);
      --danger: #ef4444;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --border: #1f2937;
      --radius: 14px;
      --shadow: 0 18px 40px rgba(0, 0, 0, 0.8);
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #020617 0, #000 70%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #game-root {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    #ui-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      pointer-events: none;
      font-size: 13px;
    }

    .hud-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .hud-pill {
      pointer-events: auto;
      background: var(--panel);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      padding: 4px 10px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(10px);
    }

    .hud-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
    }

    .hud-value {
      font-weight: 600;
    }

    /* XP bar */
    #xp-wrapper {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 10px;
      width: min(75%, 680px);
      background: var(--panel);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      overflow: hidden;
      pointer-events: auto;
    }

    #xp-inner {
      position: relative;
      width: 100%;
      height: 14px;
      background: #020617;
    }

    #xp-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      background: linear-gradient(90deg, #38bdf8, #22c55e);
      box-shadow: 0 0 16px rgba(56, 189, 248, 0.9);
      transition: width 0.18s linear;
    }

    #xp-text {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: #e5e7eb;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.9);
      pointer-events: none;
    }

    /* Start / Game Over screens */
    .screen {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .screen-card {
      min-width: min(400px, 90%);
      max-width: 480px;
      background: radial-gradient(circle at top left, var(--accent-soft), var(--panel));
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      box-shadow: var(--shadow);
      padding: 16px 18px 14px;
      transform: translateY(16px) scale(0.97);
      opacity: 0;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    }

    .screen.visible .screen-card {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .screen-title {
      font-size: 20px;
      font-weight: 700;
      margin: 0 0 4px;
    }

    .screen-sub {
      font-size: 13px;
      color: var(--text-soft);
      margin: 0 0 10px;
    }

    .screen-actions {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: var(--panel);
      padding: 6px 12px;
      font-size: 13px;
      color: var(--text);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background 0.16s ease-out, transform 0.16s ease-out, box-shadow 0.16s ease-out;
    }

    .btn:hover {
      background: #020617;
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.8);
    }

    .btn-primary {
      background: linear-gradient(135deg, #38bdf8, #22c55e);
      border-color: transparent;
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 10px 26px rgba(56, 189, 248, 0.9);
    }

    .btn-primary:hover {
      box-shadow: 0 14px 30px rgba(56, 189, 248, 1);
    }

    .btn-ghost-danger {
      border-color: rgba(248, 113, 113, 0.8);
      color: #fecaca;
    }

    .screen-row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-soft);
      margin-bottom: 3px;
    }

    .screen-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-soft);
      margin-top: 6px;
    }

    .screen-toggle input {
      accent-color: #22c55e;
    }

    /* Mobile hint */
    #hint {
      position: absolute;
      left: 8px;
      bottom: 32px;
      font-size: 11px;
      color: var(--text-soft);
      pointer-events: none;
    }

    /* Joystick (mobil) */
    #joystick-wrapper {
      position: absolute;
      left: 16px;
      bottom: 16px;
      width: 120px;
      height: 120px;
      pointer-events: none;
      touch-action: none;
    }

    #joystick-base {
      position: absolute;
      inset: 0;
      margin: auto;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at center, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.8));
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.9);
      pointer-events: auto;
    }

    #joystick-knob {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 46px;
      height: 46px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at top, #38bdf8, #0f172a);
      border: 1px solid rgba(148, 163, 184, 1);
      box-shadow: 0 10px 25px rgba(56, 189, 248, 0.9);
      touch-action: none;
    }

    @media (pointer: fine) {
      #joystick-wrapper {
        display: none;
      }
    }

    @media (max-width: 768px) {
      #xp-wrapper {
        width: 92%;
      }
      .hud-pill {
        padding: 3px 8px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      * {
        transition: none !important;
        animation: none !important;
      }
    }
  </style>
</head>
<body>
  <div id="game-root"></div>

  <div id="ui-overlay">
    <!-- HUD -->
    <div id="hud">
      <div class="hud-group">
        <div class="hud-pill">
          <span class="hud-label">HP</span>
          <span class="hud-value" id="hud-hp">100 / 100</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">LEVEL</span>
          <span class="hud-value" id="hud-level">1</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">KILLS</span>
          <span class="hud-value" id="hud-kills">0</span>
        </div>
      </div>
      <div class="hud-group">
        <div class="hud-pill">
          <span class="hud-label">TIME</span>
          <span class="hud-value" id="hud-time">00:00</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">BUILD</span>
          <span class="hud-value" id="hud-build">3D Proto</span>
        </div>
      </div>
    </div>

    <!-- XP bar -->
    <div id="xp-wrapper">
      <div id="xp-inner">
        <div id="xp-fill"></div>
        <div id="xp-text">XP 0 / 10</div>
      </div>
    </div>

    <!-- Mobile hint -->
    <div id="hint">
      PC: WASD / ok tuşları · Mobil: sol alttaki joystick ile hareket<br/>
      Otomatik ateş en yakın düşmana, XP orblarını toplayarak seviye atla.
    </div>

    <!-- Start screen -->
    <div id="start-screen" class="screen visible">
      <div class="screen-card">
        <h1 class="screen-title">Nova Arena 3D</h1>
        <p class="screen-sub">
          Sonsuz 3D arenada hayatta kal, düşmanları temizle, XP topla ve seviye atla.
          <br/>
          PC’de <b>WASD / yön tuşları</b>, mobilde <b>sol alttaki joystick</b> ile hareket.
        </p>
        <div class="screen-toggle">
          <label>
            <input type="checkbox" id="sound-toggle" checked />
            Ses efektleri aktif olsun
          </label>
        </div>
        <div class="screen-actions">
          <button id="btn-start" class="btn btn-primary">▶ Başlat</button>
        </div>
      </div>
    </div>

    <!-- Game Over -->
    <div id="gameover-screen" class="screen" style="display:none;">
      <div class="screen-card">
        <h2 class="screen-title">Oyun Bitti</h2>
        <p class="screen-sub">
          Güzel bir run oldu. İstersen tekrar dene, farklı seviye kombinasyonları biriktir.
        </p>
        <div class="screen-row">
          <span>Toplam süre</span><span id="stat-time">00:00</span>
        </div>
        <div class="screen-row">
          <span>Öldürülen düşman</span><span id="stat-kills">0</span>
        </div>
        <div class="screen-row">
          <span>Ulaşılan seviye</span><span id="stat-level">1</span>
        </div>
        <div class="screen-actions">
          <button id="btn-restart" class="btn btn-primary">↻ Tekrar Oyna</button>
          <button id="btn-quit" class="btn btn-ghost-danger">⏻ Çık</button>
        </div>
      </div>
    </div>

    <!-- Mobile joystick -->
    <div id="joystick-wrapper">
      <div id="joystick-base">
        <div id="joystick-knob"></div>
      </div>
    </div>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // === TEMEL DEĞİŞKENLER ===
    const WORLD_SIZE = 220;

    let scene, camera, renderer;
    let lastTime = performance.now();
    let gameState = "start";

    const player = {
      x: 0,
      z: 0,
      y: 1.2,
      radius: 1.2,
      speed: 18,
      hp: 100,
      maxHp: 100,
      regen: 0,
      damage: 20,
      fireRate: 2.2,
      bulletSpeed: 40,
      bulletLife: 3,
      pickupRadius: 7,
      mesh: null,
    };

    const enemies = [];
    const bullets = [];
    const xpOrbs = [];

    let elapsedTime = 0;
    let killCount = 0;
    let level = 1;
    let xp = 0;
    let xpNeeded = 10;
    let spawnTimer = 0;
    let shootCooldown = 0;

    const keyState = {
      up: false,
      down: false,
      left: false,
      right: false,
    };

    // === AUDIO ===
    let audioCtx = null;
    let soundEnabled = true;

    function initAudio() {
      if (!soundEnabled || audioCtx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      audioCtx = new AC();
      audioCtx.resume && audioCtx.resume();
    }

    function playBeep(freq, duration, volume) {
      if (!audioCtx || !soundEnabled) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function playShoot() {
      playBeep(650, 0.08, 0.12);
    }

    function playPickup() {
      playBeep(440, 0.09, 0.16);
    }

    function playHit() {
      playBeep(160, 0.06, 0.12);
    }

    // === UI ELEMANLARI ===
    const hudHp = document.getElementById("hud-hp");
    const hudLevel = document.getElementById("hud-level");
    const hudKills = document.getElementById("hud-kills");
    const hudTime = document.getElementById("hud-time");
    const hudBuild = document.getElementById("hud-build");

    const xpFill = document.getElementById("xp-fill");
    const xpText = document.getElementById("xp-text");

    const startScreen = document.getElementById("start-screen");
    const gameoverScreen = document.getElementById("gameover-screen");
    const soundToggle = document.getElementById("sound-toggle");
    const btnStart = document.getElementById("btn-start");
    const btnRestart = document.getElementById("btn-restart");
    const btnQuit = document.getElementById("btn-quit");

    const statTime = document.getElementById("stat-time");
    const statKills = document.getElementById("stat-kills");
    const statLevel = document.getElementById("stat-level");

    // Joystick
    const joystickWrapper = document.getElementById("joystick-wrapper");
    const joystickBase = document.getElementById("joystick-base");
    const joystickKnob = document.getElementById("joystick-knob");

    let joystickActive = false;
    let joystickCenter = { x: 0, y: 0 };
    let joystickVec = { x: 0, z: 0 };

    // === YARDIMCI FONKSİYONLAR ===
    function clamp(v, min, max) {
      return v < min ? min : v > max ? max : v;
    }

    function formatTime(t) {
      const total = Math.floor(t);
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
    }

    function normalize2(x, z) {
      const len = Math.hypot(x, z) || 1;
      return { x: x / len, z: z / len };
    }

    // === THREE.JS SAHNE ===
    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x020617);
      scene.fog = new THREE.FogExp2(0x020617, 0.03);

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        500
      );
      camera.position.set(0, 50, 60);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.getElementById("game-root").appendChild(renderer.domElement);

      // Işıklar
      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
      dirLight.position.set(25, 40, 15);
      dirLight.castShadow = false;
      scene.add(dirLight);

      // Zemin
      const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 40, 40);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x020617,
        metalness: 0.15,
        roughness: 0.95,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid helper
      const grid = new THREE.GridHelper(WORLD_SIZE, 40, 0x243b53, 0x111827);
      grid.position.y = 0.01;
      scene.add(grid);

      // Player
      createPlayer();

      window.addEventListener("resize", onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function createPlayer() {
      const group = new THREE.Group();

      const bodyGeo = new THREE.ConeGeometry(1, 3, 16);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0x38bdf8,
        emissive: 0x0f172a,
        roughness: 0.3,
        metalness: 0.4,
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.rotation.x = Math.PI / 2; // Ucu +Z yönüne baksın
      group.add(body);

      const coreGeo = new THREE.SphereGeometry(0.4, 16, 16);
      const coreMat = new THREE.MeshStandardMaterial({
        color: 0x22c55e,
        emissive: 0x22c55e,
        emissiveIntensity: 0.8,
        roughness: 0.4,
        metalness: 0.1,
      });
      const core = new THREE.Mesh(coreGeo, coreMat);
      core.position.set(0, 0, 1.5);
      group.add(core);

      const light = new THREE.PointLight(0x38bdf8, 1.2, 20);
      light.position.set(0, 2, 0);
      group.add(light);

      group.position.set(0, player.y, 0);
      scene.add(group);

      player.mesh = group;
    }

    // === GAME STATE RESET ===
    function resetGame() {
      // Eski nesneleri sahneden temizle
      enemies.forEach((e) => scene.remove(e.mesh));
      bullets.forEach((b) => scene.remove(b.mesh));
      xpOrbs.forEach((o) => scene.remove(o.mesh));
      enemies.length = 0;
      bullets.length = 0;
      xpOrbs.length = 0;

      // Oyuncu
      player.x = 0;
      player.z = 0;
      player.hp = 100;
      player.maxHp = 100;
      player.damage = 20;
      player.fireRate = 2.2;
      player.bulletSpeed = 40;
      player.bulletLife = 3;
      player.pickupRadius = 7;

      if (player.mesh) {
        player.mesh.position.set(player.x, player.y, player.z);
      }

      elapsedTime = 0;
      killCount = 0;
      level = 1;
      xp = 0;
      xpNeeded = 10;
      spawnTimer = 0.5;
      shootCooldown = 0;

      hudBuild.textContent = "3D Proto";
    }

    // === ENEMY / BULLET / XP ===
    function spawnEnemy() {
      const angle = Math.random() * Math.PI * 2;
      const dist = 30 + Math.random() * 40;
      let x = player.x + Math.cos(angle) * dist;
      let z = player.z + Math.sin(angle) * dist;

      x = clamp(x, -WORLD_SIZE / 2 + 4, WORLD_SIZE / 2 - 4);
      z = clamp(z, -WORLD_SIZE / 2 + 4, WORLD_SIZE / 2 - 4);

      const t = Math.floor(Math.random() * 3); // 0,1,2 tip

      const geo = new THREE.SphereGeometry(1, 16, 16);
      let color = 0xf97316;
      if (t === 1) color = 0x22c55e;
      if (t === 2) color = 0xef4444;

      const mat = new THREE.MeshStandardMaterial({
        color,
        emissive: color,
        emissiveIntensity: 0.3,
        roughness: 0.4,
        metalness: 0.2,
      });

      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, 1, z);
      scene.add(mesh);

      // Zorluk scaling
      const timeFactor = 1 + elapsedTime / 120;
      const baseHp = 30 * timeFactor;
      const baseSpeed = 8 + Math.random() * 3;

      enemies.push({
        x,
        z,
        y: 1,
        radius: 1,
        speed: baseSpeed,
        hp: baseHp,
        maxHp: baseHp,
        damage: 10 * timeFactor,
        type: t,
        mesh,
      });
    }

    function spawnBullet(dirX, dirZ) {
      const n = normalize2(dirX, dirZ);
      const geo = new THREE.SphereGeometry(0.25, 8, 8);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xfacc15,
        emissive: 0xfacc15,
        emissiveIntensity: 1,
        roughness: 0.3,
        metalness: 0.1,
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(
        player.x + n.x * 1.6,
        1,
        player.z + n.z * 1.6
      );
      scene.add(mesh);

      bullets.push({
        x: mesh.position.x,
        z: mesh.position.z,
        vx: n.x * player.bulletSpeed,
        vz: n.z * player.bulletSpeed,
        radius: 0.25,
        life: player.bulletLife,
        mesh,
      });

      playShoot();
    }

    function spawnXpOrb(x, z) {
      const geo = new THREE.SphereGeometry(0.3, 8, 8);
      const mat = new THREE.MeshStandardMaterial({
        color: 0x22c55e,
        emissive: 0x16a34a,
        emissiveIntensity: 0.9,
        roughness: 0.4,
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, 0.6, z);
      scene.add(mesh);

      xpOrbs.push({
        x,
        z,
        radius: 0.35,
        value: 1 + Math.random(),
        mesh,
      });
    }

    function killEnemy(index) {
      const e = enemies[index];
      spawnXpOrb(e.x, e.z);
      scene.remove(e.mesh);
      enemies.splice(index, 1);
      killCount++;
    }

    // === UPDATE FONKSİYONLARI ===
    function updatePlayer(dt) {
      let moveX = 0;
      let moveZ = 0;

      if (keyState.up) moveZ -= 1;
      if (keyState.down) moveZ += 1;
      if (keyState.left) moveX -= 1;
      if (keyState.right) moveX += 1;

      // Joystick yönünü ekle (mobil)
      moveX += joystickVec.x;
      moveZ += joystickVec.z;

      if (moveX !== 0 || moveZ !== 0) {
        const n = normalize2(moveX, moveZ);
        player.x += n.x * player.speed * dt;
        player.z += n.z * player.speed * dt;
      }

      player.x = clamp(player.x, -WORLD_SIZE / 2 + 2, WORLD_SIZE / 2 - 2);
      player.z = clamp(player.z, -WORLD_SIZE / 2 + 2, WORLD_SIZE / 2 - 2);

      if (player.mesh) {
        player.mesh.position.set(player.x, player.y, player.z);
      }

      if (player.regen > 0) {
        player.hp = clamp(player.hp + player.regen * dt, 0, player.maxHp);
      }
    }

    function updateEnemies(dt) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = player.x - e.x;
        const dz = player.z - e.z;
        const dist = Math.hypot(dx, dz) || 1;
        let dir = normalize2(dx, dz);

        let vx = dir.x * e.speed;
        let vz = dir.z * e.speed;

        // Farklı enemy davranışları
        if (e.type === 1) {
          // Hızlı-chaser
          const factor = dist < 8 ? 1.8 : 1.3;
          vx *= factor;
          vz *= factor;
        } else if (e.type === 2) {
          // Zigzag
          const wave = Math.sin(elapsedTime * 3 + i) * 0.7;
          const side = normalize2(-dir.z, dir.x);
          vx += side.x * e.speed * 0.5 * wave;
          vz += side.z * e.speed * 0.5 * wave;
        }

        e.x += vx * dt;
        e.z += vz * dt;

        e.x = clamp(e.x, -WORLD_SIZE / 2 + 2, WORLD_SIZE / 2 - 2);
        e.z = clamp(e.z, -WORLD_SIZE / 2 + 2, WORLD_SIZE / 2 - 2);

        e.mesh.position.set(e.x, e.y, e.z);

        const dPlayer = Math.hypot(player.x - e.x, player.z - e.z);
        if (dPlayer < player.radius + e.radius) {
          player.hp -= e.damage * dt;
          if (player.hp <= 0) {
            player.hp = 0;
            playHit();
            onGameOver();
            return;
          }
        }

        if (e.hp <= 0) {
          killEnemy(i);
        }
      }
    }

    function updateBullets(dt) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx * dt;
        b.z += b.vz * dt;
        b.life -= dt;
        b.mesh.position.set(b.x, 1, b.z);

        if (
          Math.abs(b.x) > WORLD_SIZE / 2 + 5 ||
          Math.abs(b.z) > WORLD_SIZE / 2 + 5 ||
          b.life <= 0
        ) {
          scene.remove(b.mesh);
          bullets.splice(i, 1);
          continue;
        }

        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          const d = Math.hypot(e.x - b.x, e.z - b.z);
          if (d < e.radius + 0.4) {
            e.hp -= player.damage;
            playHit();
            scene.remove(b.mesh);
            bullets.splice(i, 1);
            if (e.hp <= 0) {
              killEnemy(j);
            }
            break;
          }
        }
      }
    }

    function updateXpOrbs(dt) {
      for (let i = xpOrbs.length - 1; i >= 0; i--) {
        const orb = xpOrbs[i];
        const dx = player.x - orb.x;
        const dz = player.z - orb.z;
        const dist = Math.hypot(dx, dz);

        if (dist < player.pickupRadius) {
          const pull = 10 * dt;
          const n = normalize2(dx, dz);
          orb.x += n.x * pull;
          orb.z += n.z * pull;
          orb.mesh.position.set(orb.x, 0.6, orb.z);
        }

        if (dist < player.radius + orb.radius) {
          xp += orb.value;
          playPickup();
          scene.remove(orb.mesh);
          xpOrbs.splice(i, 1);

          while (xp >= xpNeeded) {
            xp -= xpNeeded;
            level++;
            xpNeeded = 10 + level * 5;
            // Basit scaling
            player.damage *= 1.05;
            player.maxHp += 4;
            player.hp = Math.min(player.maxHp, player.hp + 12);
          }
        }
      }
    }

    function autoShoot(dt) {
      shootCooldown -= dt;
      if (shootCooldown > 0) return;
      if (enemies.length === 0) return;

      let nearest = null;
      let best = Infinity;
      for (const e of enemies) {
        const d = Math.hypot(e.x - player.x, e.z - player.z);
        if (d < best) {
          best = d;
          nearest = e;
        }
      }
      if (!nearest) return;

      spawnBullet(nearest.x - player.x, nearest.z - player.z);
      shootCooldown = 1 / player.fireRate;
    }

    function updateHud() {
      hudHp.textContent = `${Math.round(player.hp)} / ${player.maxHp}`;
      hudLevel.textContent = level.toString();
      hudKills.textContent = killCount.toString();
      hudTime.textContent = formatTime(elapsedTime);

      const pct = clamp((xp / xpNeeded) * 100, 0, 100);
      xpFill.style.width = pct + "%";
      xpText.textContent = `XP ${Math.floor(xp)} / ${xpNeeded}`;
    }

    function updateCamera(dt) {
      const target = new THREE.Vector3(player.x, 40, player.z + 40);
      camera.position.lerp(target, 0.12);
      camera.lookAt(player.x, 0, player.z);
    }

    // === GAME LOOP ===
    function update(dt) {
      elapsedTime += dt;

      // Enemy spawn
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        spawnEnemy();
        const base = 1.5 - elapsedTime * 0.01;
        spawnTimer = Math.max(0.5, base + Math.random() * 0.6);
      }

      updatePlayer(dt);
      updateEnemies(dt);
      updateBullets(dt);
      updateXpOrbs(dt);
      autoShoot(dt);
      updateHud();
      updateCamera(dt);
    }

    function loop(now) {
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      if (gameState === "playing") {
        update(dt);
      }

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    // === GAME STATE ===
    function onGameOver() {
      if (gameState !== "playing") return;
      gameState = "gameover";
      statTime.textContent = formatTime(elapsedTime);
      statKills.textContent = killCount.toString();
      statLevel.textContent = level.toString();

      gameoverScreen.style.display = "flex";
      requestAnimationFrame(() => {
        gameoverScreen.classList.add("visible");
      });
    }

    // === INPUT: KEYBOARD ===
    window.addEventListener("keydown", (e) => {
      if (e.code === "KeyW" || e.code === "ArrowUp") keyState.up = true;
      if (e.code === "KeyS" || e.code === "ArrowDown") keyState.down = true;
      if (e.code === "KeyA" || e.code === "ArrowLeft") keyState.left = true;
      if (e.code === "KeyD" || e.code === "ArrowRight") keyState.right = true;
    });

    window.addEventListener("keyup", (e) => {
      if (e.code === "KeyW" || e.code === "ArrowUp") keyState.up = false;
      if (e.code === "KeyS" || e.code === "ArrowDown") keyState.down = false;
      if (e.code === "KeyA" || e.code === "ArrowLeft") keyState.left = false;
      if (e.code === "KeyD" || e.code === "ArrowRight") keyState.right = false;
    });

    // === INPUT: JOYSTICK ===
    function getPos(event, element) {
      const rect = element.getBoundingClientRect();
      const clientX = event.touches ? event.touches[0].clientX : event.clientX;
      const clientY = event.touches ? event.touches[0].clientY : event.clientY;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top,
      };
    }

    function joystickStart(event) {
      event.preventDefault();
      joystickActive = true;
      const rect = joystickBase.getBoundingClientRect();
      joystickCenter.x = rect.width / 2;
      joystickCenter.y = rect.height / 2;
      joystickMove(event);
    }

    function joystickMove(event) {
      if (!joystickActive) return;
      event.preventDefault();
      const pos = getPos(event, joystickBase);
      const dx = pos.x - joystickCenter.x;
      const dy = pos.y - joystickCenter.y;
      const maxDist = joystickBase.clientWidth / 2 - 10;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;

      let nx = dx;
      let ny = dy;
      if (dist > maxDist) {
        const ratio = maxDist / dist;
        nx *= ratio;
        ny *= ratio;
      }

      joystickKnob.style.transform =
        `translate(${nx}px, ${ny}px) translate(-50%, -50%)`;

      const normX = nx / maxDist;
      const normY = ny / maxDist;

      joystickVec.x = normX;
      joystickVec.z = normY; // yukarı negatif, aşağı pozitif -> Z eksenine map
    }

    function joystickEnd(event) {
      event && event.preventDefault();
      joystickActive = false;
      joystickVec.x = 0;
      joystickVec.z = 0;
      joystickKnob.style.transform = "translate(-50%, -50%)";
    }

    joystickBase.addEventListener("pointerdown", joystickStart);
    window.addEventListener("pointermove", joystickMove);
    window.addEventListener("pointerup", joystickEnd);
    window.addEventListener("pointercancel", joystickEnd);

    // === BUTONLAR ===
    soundToggle.addEventListener("change", () => {
      soundEnabled = soundToggle.checked;
      if (soundEnabled && gameState === "playing") {
        initAudio();
      }
    });

    btnStart.addEventListener("click", () => {
      soundEnabled = soundToggle.checked;
      if (soundEnabled) initAudio();

      startScreen.classList.remove("visible");
      startScreen.style.display = "none";

      resetGame();
      gameState = "playing";
    });

    btnRestart.addEventListener("click", () => {
      gameoverScreen.classList.remove("visible");
      gameoverScreen.style.display = "none";
      resetGame();
      gameState = "playing";
    });

    btnQuit.addEventListener("click", () => {
      gameoverScreen.classList.remove("visible");
      gameoverScreen.style.display = "none";
      gameState = "start";
      startScreen.style.display = "flex";
      requestAnimationFrame(() => {
        startScreen.classList.add("visible");
      });
    });

    // === BAŞLAT ===
    initThree();
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
