<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Nova Arena 3D · Rogue Survivor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --panel: rgba(15, 23, 42, 0.96);
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.18);
      --danger: #ef4444;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --border: #1f2937;
      --radius: 14px;
      --shadow: 0 18px 40px rgba(0, 0, 0, 0.8);
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #0b1120 0, #020617 45%, #000 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #game-root {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    #ui-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      pointer-events: none;
      font-size: 13px;
    }

    .hud-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .hud-pill {
      pointer-events: auto;
      background: var(--panel);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      padding: 4px 10px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(10px);
    }

    .hud-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
    }

    .hud-value {
      font-weight: 600;
    }

    /* XP bar */
    #xp-wrapper {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 10px;
      width: min(75%, 680px);
      background: var(--panel);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      overflow: hidden;
      pointer-events: auto;
    }

    #xp-inner {
      position: relative;
      width: 100%;
      height: 16px;
      background: #020617;
    }

    #xp-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      background: linear-gradient(90deg, #38bdf8, #22c55e);
      box-shadow: 0 0 20px rgba(56, 189, 248, 1);
      transition: width 0.18s linear;
    }

    #xp-text {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: #e5e7eb;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.9);
      pointer-events: none;
    }

    /* Screens */
    .screen {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .screen-card {
      min-width: min(400px, 90%);
      max-width: 480px;
      background: radial-gradient(circle at top left, var(--accent-soft), var(--panel));
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      box-shadow: var(--shadow);
      padding: 18px 18px 14px;
      transform: translateY(16px) scale(0.97);
      opacity: 0;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    }

    .screen.visible .screen-card {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .screen-title {
      font-size: 20px;
      font-weight: 700;
      margin: 0 0 4px;
    }

    .screen-sub {
      font-size: 13px;
      color: var(--text-soft);
      margin: 0 0 10px;
    }

    .screen-actions {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      background: var(--panel);
      padding: 6px 12px;
      font-size: 13px;
      color: var(--text);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background 0.16s ease-out, transform 0.16s ease-out, box-shadow 0.16s ease-out;
    }

    .btn:hover {
      background: #020617;
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.8);
    }

    .btn-primary {
      background: linear-gradient(135deg, #38bdf8, #22c55e);
      border-color: transparent;
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 10px 26px rgba(56, 189, 248, 0.9);
    }

    .btn-primary:hover {
      box-shadow: 0 14px 30px rgba(56, 189, 248, 1);
    }

    .btn-ghost-danger {
      border-color: rgba(248, 113, 113, 0.9);
      color: #fecaca;
    }

    .screen-row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-soft);
      margin-bottom: 3px;
    }

    .screen-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-soft);
      margin-top: 6px;
    }

    .screen-toggle input {
      accent-color: #22c55e;
    }

    /* Upgrade screen */
    #upgrade-screen {
      display: none;
    }

    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .upgrade-card {
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      background: rgba(15, 23, 42, 0.9);
      padding: 8px;
      cursor: pointer;
      transition: transform 0.15s ease-out, box-shadow 0.15s ease-out, border-color 0.15s ease-out, background 0.15s ease-out;
      font-size: 12px;
    }

    .upgrade-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 24px rgba(56, 189, 248, 0.6);
      border-color: #38bdf8;
      background: radial-gradient(circle at top left, rgba(56,189,248,0.12), rgba(15,23,42,0.95));
    }

    .upgrade-name {
      font-weight: 600;
      margin-bottom: 2px;
      font-size: 13px;
    }

    .upgrade-tag {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #4ade80;
      margin-bottom: 4px;
    }

    .upgrade-desc {
      font-size: 11px;
      color: var(--text-soft);
    }

    /* Hint */
    #hint {
      position: absolute;
      left: 8px;
      bottom: 12px;
      font-size: 11px;
      color: var(--text-soft);
      pointer-events: none;
    }

    /* Joystick */
    #joystick-wrapper {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      width: 130px;
      height: 130px;
      pointer-events: none;
      touch-action: none;
    }

    #joystick-base {
      position: absolute;
      inset: 0;
      margin: auto;
      width: 110px;
      height: 110px;
      border-radius: 50%;
      border: 1px solid rgba(148, 163, 184, 0.9);
      background: radial-gradient(circle at center, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.85));
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.9);
      pointer-events: auto;
    }

    #joystick-knob {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at top, #38bdf8, #0f172a);
      border: 1px solid rgba(148, 163, 184, 1);
      box-shadow: 0 10px 25px rgba(56, 189, 248, 0.9);
      touch-action: none;
    }

    @media (max-width: 768px) {
      #xp-wrapper {
        width: 92%;
      }
      .hud-pill {
        padding: 3px 8px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      * {
        transition: none !important;
        animation: none !important;
      }
    }
  </style>
</head>
<body>
  <div id="game-root"></div>

  <div id="ui-overlay">
    <!-- HUD -->
    <div id="hud">
      <div class="hud-group">
        <div class="hud-pill">
          <span class="hud-label">HP</span>
          <span class="hud-value" id="hud-hp">100 / 100</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">LEVEL</span>
          <span class="hud-value" id="hud-level">1</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">KILLS</span>
          <span class="hud-value" id="hud-kills">0</span>
        </div>
      </div>
      <div class="hud-group">
        <div class="hud-pill">
          <span class="hud-label">TIME</span>
          <span class="hud-value" id="hud-time">00:00</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">BUILD</span>
          <span class="hud-value" id="hud-build">3D Alpha</span>
        </div>
      </div>
    </div>

    <!-- XP bar -->
    <div id="xp-wrapper">
      <div id="xp-inner">
        <div id="xp-fill"></div>
        <div id="xp-text">XP 0 / 10</div>
      </div>
    </div>

    <!-- Hint -->
    <div id="hint">
      PC: WASD / ok tuşları · Mobil: sol ortadaki joystick<br/>
      Otomatik ateş en yakın düşmana, XP orblarını toplayarak seviye atla. Level-up olduğunda bir upgrade seç.
    </div>

    <!-- Start screen -->
    <div id="start-screen" class="screen visible">
      <div class="screen-card">
        <h1 class="screen-title">Nova Arena 3D</h1>
        <p class="screen-sub">
          Sonsuz 3D arenada hayatta kal, farklı düşman tiplerini temizle, XP topla ve level-up olduğunda build'ini güçlendir.
        </p>
        <div class="screen-toggle">
          <label>
            <input type="checkbox" id="sound-toggle" checked />
            Ses efektleri aktif olsun
          </label>
        </div>
        <div class="screen-actions">
          <button id="btn-start" class="btn btn-primary">▶ Başlat</button>
        </div>
      </div>
    </div>

    <!-- Game Over -->
    <div id="gameover-screen" class="screen" style="display:none;">
      <div class="screen-card">
        <h2 class="screen-title">Oyun Bitti</h2>
        <p class="screen-sub">
          Güzel bir run oldu. İstersen farklı upgrade kombinasyonları deneyerek tekrar oyna.
        </p>
        <div class="screen-row">
          <span>Toplam süre</span><span id="stat-time">00:00</span>
        </div>
        <div class="screen-row">
          <span>Öldürülen düşman</span><span id="stat-kills">0</span>
        </div>
        <div class="screen-row">
          <span>Ulaşılan seviye</span><span id="stat-level">1</span>
        </div>
        <div class="screen-actions">
          <button id="btn-restart" class="btn btn-primary">↻ Tekrar Oyna</button>
          <button id="btn-quit" class="btn btn-ghost-danger">⏻ Çık</button>
        </div>
      </div>
    </div>

    <!-- Upgrade screen -->
    <div id="upgrade-screen" class="screen">
      <div class="screen-card">
        <h2 class="screen-title">Level Up!</h2>
        <p class="screen-sub">
          Bir upgrade seç, build'ini şekillendir:
        </p>
        <div id="upgrade-options" class="upgrade-grid"></div>
      </div>
    </div>

    <!-- Mobile joystick -->
    <div id="joystick-wrapper">
      <div id="joystick-base">
        <div id="joystick-knob"></div>
      </div>
    </div>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // === TEMEL DEĞİŞKENLER ===
    const WORLD_SIZE = 230;

    let scene, camera, renderer;
    let lastTime = performance.now();
    let gameState = "start";
    let isPausedForUpgrade = false;

    const player = {
      x: 0,
      z: 0,
      y: 1.5,
      radius: 1.3,
      speed: 18,
      hp: 100,
      maxHp: 100,
      regen: 0,
      damage: 22,
      fireRate: 2.4,
      bulletSpeed: 40,
      bulletLife: 3,
      pickupRadius: 7.5,
      mesh: null,
    };

    const enemies = [];
    const bullets = [];
    const xpOrbs = [];

    let elapsedTime = 0;
    let killCount = 0;
    let level = 1;
    let xp = 0;
    let xpNeeded = 10;
    let spawnTimer = 0;
    let shootCooldown = 0;
    let pendingLevelUps = 0;

    const keyState = { up: false, down: false, left: false, right: false };

    // === AUDIO ===
    let audioCtx = null;
    let soundEnabled = true;

    function initAudio() {
      if (!soundEnabled || audioCtx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      audioCtx = new AC();
      audioCtx.resume && audioCtx.resume();
    }

    function playBeep(freq, duration, volume) {
      if (!audioCtx || !soundEnabled) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function playShoot() {
      playBeep(720, 0.09, 0.35);
    }

    function playPickup() {
      playBeep(540, 0.12, 0.4);
    }

    function playHit() {
      playBeep(160, 0.1, 0.45);
    }

    function playLevelUp() {
      playBeep(880, 0.14, 0.5);
      setTimeout(() => playBeep(1180, 0.14, 0.45), 90);
    }

    // === UI ELEMANLARI ===
    const hudHp = document.getElementById("hud-hp");
    const hudLevel = document.getElementById("hud-level");
    const hudKills = document.getElementById("hud-kills");
    const hudTime = document.getElementById("hud-time");
    const hudBuild = document.getElementById("hud-build");

    const xpFill = document.getElementById("xp-fill");
    const xpText = document.getElementById("xp-text");

    const startScreen = document.getElementById("start-screen");
    const gameoverScreen = document.getElementById("gameover-screen");
    const upgradeScreen = document.getElementById("upgrade-screen");
    const upgradeOptions = document.getElementById("upgrade-options");

    const soundToggle = document.getElementById("sound-toggle");
    const btnStart = document.getElementById("btn-start");
    const btnRestart = document.getElementById("btn-restart");
    const btnQuit = document.getElementById("btn-quit");

    const statTime = document.getElementById("stat-time");
    const statKills = document.getElementById("stat-kills");
    const statLevel = document.getElementById("stat-level");

    // Joystick
    const joystickBase = document.getElementById("joystick-base");
    const joystickKnob = document.getElementById("joystick-knob");
    let joystickActive = false;
    let joystickCenter = { x: 0, y: 0 };
    let joystickVec = { x: 0, z: 0 };

    // === UPGRADES ===
    let currentUpgradeChoices = [];

    const ALL_UPGRADES = [
      {
        id: "fire_rate_1",
        name: "Rapid Fire",
        tag: "Attack",
        desc: "Ateş hızın %30 artar.",
        apply() { player.fireRate *= 1.3; }
      },
      {
        id: "fire_rate_2",
        name: "Bullet Storm",
        tag: "Attack",
        desc: "Ateş hızın %20 artar, mermi ömrü +1s.",
        apply() { player.fireRate *= 1.2; player.bulletLife += 1; }
      },
      {
        id: "damage_1",
        name: "Power Shot",
        tag: "Attack",
        desc: "Hasarın %35 artar.",
        apply() { player.damage *= 1.35; }
      },
      {
        id: "damage_2",
        name: "Critical Core",
        tag: "Attack",
        desc: "Hasarın %20 artar, her vuruşta küçük ekstra hasar şansı.",
        apply() { player.damage *= 1.2; player.critChance = (player.critChance || 0) + 0.12; }
      },
      {
        id: "hp_1",
        name: "Titan Shell",
        tag: "Defense",
        desc: "Max HP +35, anında +25 HP doldur.",
        apply() { player.maxHp += 35; player.hp = Math.min(player.maxHp, player.hp + 25); }
      },
      {
        id: "regen_1",
        name: "Nanobot Regen",
        tag: "Defense",
        desc: "Saniyede +1.8 HP yenilenme.",
        apply() { player.regen += 1.8; }
      },
      {
        id: "speed_1",
        name: "Vector Boots",
        tag: "Utility",
        desc: "Hareket hızın %25 artar.",
        apply() { player.speed *= 1.25; }
      },
      {
        id: "pickup_1",
        name: "Magnet Core",
        tag: "Utility",
        desc: "XP toplama yarıçapın %40 artar.",
        apply() { player.pickupRadius *= 1.4; }
      },
      {
        id: "control_1",
        name: "Drift Thrusters",
        tag: "Utility",
        desc: "Hareket daha akıcı, kamera takibi daha yumuşak.",
        apply() { cameraFollowSmooth = 0.16; }
      }
    ];

    // === YARDIMCI FONKSİYONLAR ===
    function clamp(v, min, max) {
      return v < min ? min : v > max ? max : v;
    }

    function formatTime(t) {
      const total = Math.floor(t);
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
    }

    function normalize2(x, z) {
      const len = Math.hypot(x, z) || 1;
      return { x: x / len, z: z / len };
    }

    function sampleUpgrades(n) {
      const pool = ALL_UPGRADES.slice();
      const choices = [];
      for (let i = 0; i < n && pool.length > 0; i++) {
        const idx = Math.floor(Math.random() * pool.length);
        choices.push(pool.splice(idx, 1)[0]);
      }
      return choices;
    }

    function queueLevelUp() {
      pendingLevelUps++;
      if (!isPausedForUpgrade && gameState === "playing") {
        openUpgradeChoice();
      }
    }

    function openUpgradeChoice() {
      if (pendingLevelUps <= 0) return;
      isPausedForUpgrade = true;
      pendingLevelUps--;

      playLevelUp();

      currentUpgradeChoices = sampleUpgrades(3);
      upgradeOptions.innerHTML = "";

      currentUpgradeChoices.forEach((upg, index) => {
        const card = document.createElement("div");
        card.className = "upgrade-card";
        card.innerHTML = `
          <div class="upgrade-tag">${upg.tag}</div>
          <div class="upgrade-name">${upg.name}</div>
          <div class="upgrade-desc">${upg.desc}</div>
        `;
        card.addEventListener("click", () => {
          upg.apply();
          closeUpgradeScreen();
        });
        upgradeOptions.appendChild(card);
      });

      upgradeScreen.style.display = "flex";
      requestAnimationFrame(() => {
        upgradeScreen.classList.add("visible");
      });
    }

    function closeUpgradeScreen() {
      upgradeScreen.classList.remove("visible");
      setTimeout(() => {
        upgradeScreen.style.display = "none";
        isPausedForUpgrade = false;
        if (pendingLevelUps > 0 && gameState === "playing") {
          openUpgradeChoice();
        }
      }, 150);
    }

    // === THREE.JS SAHNE ===
    let cameraFollowSmooth = 0.12;

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x020617);
      scene.fog = new THREE.FogExp2(0x020617, 0.015);

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        700
      );
      camera.position.set(0, 45, 55);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.getElementById("game-root").appendChild(renderer.domElement);

      // Işıklar
      const ambient = new THREE.AmbientLight(0xffffff, 0.95);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
      dirLight.position.set(30, 60, 30);
      scene.add(dirLight);

      const rimLight = new THREE.DirectionalLight(0x38bdf8, 0.7);
      rimLight.position.set(-40, 50, -40);
      scene.add(rimLight);

      // Zemin
      const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 40, 40);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x020617,
        metalness: 0.3,
        roughness: 0.9,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Neon grid çizgileri
      const grid = new THREE.GridHelper(WORLD_SIZE, 40, 0x38bdf8, 0x1e293b);
      grid.position.y = 0.02;
      scene.add(grid);

      // Arena sütunları
      createPillars();

      // Yıldızlar
      createStarField();

      // Player
      createPlayer();

      window.addEventListener("resize", onWindowResize);
    }

    function createPillars() {
      const pillarGeo = new THREE.CylinderGeometry(1.3, 1.3, 12, 12);
      const pillarMat = new THREE.MeshStandardMaterial({
        color: 0x0f172a,
        emissive: 0x1d4ed8,
        emissiveIntensity: 0.4,
        metalness: 0.5,
        roughness: 0.4,
      });
      const positions = [
        [-WORLD_SIZE / 2 + 10, -WORLD_SIZE / 2 + 10],
        [WORLD_SIZE / 2 - 10, -WORLD_SIZE / 2 + 10],
        [-WORLD_SIZE / 2 + 10, WORLD_SIZE / 2 - 10],
        [WORLD_SIZE / 2 - 10, WORLD_SIZE / 2 - 10],
        [0, -WORLD_SIZE / 2 + 14],
        [0, WORLD_SIZE / 2 - 14]
      ];
      positions.forEach(([x,z]) => {
        const p = new THREE.Mesh(pillarGeo, pillarMat);
        p.position.set(x, 6, z);
        scene.add(p);
      });
    }

    function createStarField() {
      const starCount = 900;
      const positions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        positions[i * 3 + 0] = (Math.random() - 0.5) * 450;
        positions[i * 3 + 1] = 40 + Math.random() * 120;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 450;
      }
      const starGeo = new THREE.BufferGeometry();
      starGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const starMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.1,
        sizeAttenuation: true,
      });
      const stars = new THREE.Points(starGeo, starMat);
      scene.add(stars);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function createPlayer() {
      const group = new THREE.Group();

      // Gövde (kapsül)
      const bodyGeo = new THREE.CylinderGeometry(0.9, 0.9, 3.6, 18);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0x38bdf8,
        emissive: 0x1d4ed8,
        emissiveIntensity: 0.9,
        roughness: 0.35,
        metalness: 0.7,
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      group.add(body);

      const headGeo = new THREE.SphereGeometry(1.1, 20, 20);
      const headMat = new THREE.MeshStandardMaterial({
        color: 0x22c55e,
        emissive: 0x22c55e,
        emissiveIntensity: 1,
        metalness: 0.4,
        roughness: 0.3,
      });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 2.3;
      group.add(head);

      const thrusterGeo = new THREE.ConeGeometry(0.9, 1.6, 16);
      const thrusterMat = new THREE.MeshStandardMaterial({
        color: 0xf97316,
        emissive: 0xf97316,
        emissiveIntensity: 0.8,
        metalness: 0.6,
        roughness: 0.4,
      });
      const thruster = new THREE.Mesh(thrusterGeo, thrusterMat);
      thruster.position.y = -2.2;
      thruster.rotation.x = Math.PI;
      group.add(thruster);

      const wingGeo = new THREE.BoxGeometry(0.4, 1.8, 3.6);
      const wingMat = new THREE.MeshStandardMaterial({
        color: 0x0ea5e9,
        emissive: 0x0ea5e9,
        emissiveIntensity: 0.6,
        metalness: 0.7,
        roughness: 0.4,
      });
      const wingL = new THREE.Mesh(wingGeo, wingMat);
      wingL.position.set(-1.2, 0.2, 0);
      const wingR = wingL.clone();
      wingR.position.x = 1.2;
      group.add(wingL, wingR);

      const light = new THREE.PointLight(0x38bdf8, 1.5, 22);
      light.position.set(0, 3, 0);
      group.add(light);

      group.position.set(0, player.y, 0);
      group.rotation.y = Math.PI; // ileri doğru bakış
      scene.add(group);

      player.mesh = group;
    }

    // === GAME STATE RESET ===
    function resetGame() {
      enemies.forEach(e => scene.remove(e.mesh));
      bullets.forEach(b => scene.remove(b.mesh));
      xpOrbs.forEach(o => scene.remove(o.mesh));
      enemies.length = 0;
      bullets.length = 0;
      xpOrbs.length = 0;

      player.x = 0;
      player.z = 0;
      player.hp = 100;
      player.maxHp = 100;
      player.regen = 0;
      player.damage = 22;
      player.fireRate = 2.4;
      player.bulletSpeed = 40;
      player.bulletLife = 3;
      player.pickupRadius = 7.5;
      player.critChance = 0;

      if (player.mesh) {
        player.mesh.position.set(player.x, player.y, player.z);
      }

      elapsedTime = 0;
      killCount = 0;
      level = 1;
      xp = 0;
      xpNeeded = 10;
      spawnTimer = 0.7;
      shootCooldown = 0;
      pendingLevelUps = 0;
      cameraFollowSmooth = 0.12;

      hudBuild.textContent = "3D Alpha";
    }

    // === ENEMIES / BULLETS / XP ===
    function spawnEnemy() {
      const angle = Math.random() * Math.PI * 2;
      const dist = 35 + Math.random() * 45;
      let x = player.x + Math.cos(angle) * dist;
      let z = player.z + Math.sin(angle) * dist;

      x = clamp(x, -WORLD_SIZE / 2 + 6, WORLD_SIZE / 2 - 6);
      z = clamp(z, -WORLD_SIZE / 2 + 6, WORLD_SIZE / 2 - 6);

      const t = Math.floor(Math.random() * 4); // 0–3 arası tip

      let geo, color, emissive, radius, baseHp, baseSpeed, damage;
      const timeFactor = 1 + elapsedTime / 120;

      switch (t) {
        case 0: // basic chaser
          geo = new THREE.SphereGeometry(1.1, 16, 16);
          color = 0xf97316;
          emissive = 0xf97316;
          radius = 1.1;
          baseHp = 35 * timeFactor;
          baseSpeed = 10;
          damage = 8 * timeFactor;
          break;
        case 1: // fast cube
          geo = new THREE.BoxGeometry(1.4, 1.4, 1.4);
          color = 0x22c55e;
          emissive = 0x22c55e;
          radius = 1.2;
          baseHp = 30 * timeFactor;
          baseSpeed = 14;
          damage = 10 * timeFactor;
          break;
        case 2: // tank
          geo = new THREE.CylinderGeometry(1.5, 1.5, 2.4, 10);
          color = 0x64748b;
          emissive = 0x0f172a;
          radius = 1.5;
          baseHp = 75 * timeFactor;
          baseSpeed = 6.5;
          damage = 14 * timeFactor;
          break;
        case 3: // turret-like
          geo = new THREE.ConeGeometry(1.1, 2.4, 14);
          color = 0x6366f1;
          emissive = 0x4f46e5;
          radius = 1.1;
          baseHp = 45 * timeFactor;
          baseSpeed = 5;
          damage = 12 * timeFactor;
          break;
      }

      const mat = new THREE.MeshStandardMaterial({
        color,
        emissive,
        emissiveIntensity: 0.6,
        roughness: 0.35,
        metalness: 0.6,
      });

      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, 1.1, z);
      scene.add(mesh);

      enemies.push({
        x,
        z,
        y: 1.1,
        radius,
        speed: baseSpeed,
        hp: baseHp,
        maxHp: baseHp,
        damage,
        type: t,
        mesh,
        fireCooldown: 1.5 + Math.random(),
      });
    }

    function spawnBullet(dirX, dirZ, fromPlayer = true, origin = null, speedOverride = null) {
      const n = normalize2(dirX, dirZ);
      const geo = new THREE.SphereGeometry(fromPlayer ? 0.28 : 0.22, 10, 10);
      const mat = new THREE.MeshStandardMaterial({
        color: fromPlayer ? 0xfacc15 : 0x6366f1,
        emissive: fromPlayer ? 0xfacc15 : 0x6366f1,
        emissiveIntensity: 1,
        roughness: 0.3,
        metalness: 0.3,
      });
      const mesh = new THREE.Mesh(geo, mat);

      const startX = origin ? origin.x : player.x;
      const startZ = origin ? origin.z : player.z;

      mesh.position.set(
        startX + n.x * 1.8,
        1.1,
        startZ + n.z * 1.8
      );
      scene.add(mesh);

      const speed = speedOverride || player.bulletSpeed;

      bullets.push({
        x: mesh.position.x,
        z: mesh.position.z,
        vx: n.x * speed,
        vz: n.z * speed,
        radius: fromPlayer ? 0.3 : 0.25,
        life: fromPlayer ? player.bulletLife : 2.4,
        mesh,
        fromPlayer,
      });

      if (fromPlayer) playShoot();
    }

    function spawnXpOrb(x, z) {
      const geo = new THREE.SphereGeometry(0.35, 10, 10);
      const mat = new THREE.MeshStandardMaterial({
        color: 0x22c55e,
        emissive: 0x16a34a,
        emissiveIntensity: 1,
        roughness: 0.35,
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, 0.7, z);
      scene.add(mesh);

      xpOrbs.push({
        x,
        z,
        radius: 0.4,
        value: 1 + Math.random(),
        mesh,
      });
    }

    function killEnemy(index) {
      const e = enemies[index];
      spawnXpOrb(e.x, e.z);
      scene.remove(e.mesh);
      enemies.splice(index, 1);
      killCount++;
    }

    // === UPDATE ===
    function updatePlayer(dt) {
      let moveX = 0;
      let moveZ = 0;

      if (keyState.up) moveZ -= 1;
      if (keyState.down) moveZ += 1;
      if (keyState.left) moveX -= 1;
      if (keyState.right) moveX += 1;

      moveX += joystickVec.x;
      moveZ += joystickVec.z;

      if (moveX !== 0 || moveZ !== 0) {
        const n = normalize2(moveX, moveZ);
        player.x += n.x * player.speed * dt;
        player.z += n.z * player.speed * dt;

        if (player.mesh) {
          const angle = Math.atan2(n.x, n.z);
          player.mesh.rotation.y = angle;
        }
      }

      player.x = clamp(player.x, -WORLD_SIZE / 2 + 3, WORLD_SIZE / 2 - 3);
      player.z = clamp(player.z, -WORLD_SIZE / 2 + 3, WORLD_SIZE / 2 - 3);

      if (player.mesh) {
        player.mesh.position.set(player.x, player.y, player.z);
      }

      if (player.regen > 0) {
        player.hp = clamp(player.hp + player.regen * dt, 0, player.maxHp);
      }
    }

    function updateEnemies(dt) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = player.x - e.x;
        const dz = player.z - e.z;
        const dist = Math.hypot(dx, dz) || 1;
        let dir = normalize2(dx, dz);

        let vx = dir.x * e.speed;
        let vz = dir.z * e.speed;

        // Farklı davranışlar
        if (e.type === 1) {
          // fast cube - bazen dash
          const dashPhase = Math.sin(elapsedTime * 4 + i);
          if (dashPhase > 0.7 && dist > 8) {
            vx *= 2.2;
            vz *= 2.2;
          } else {
            vx *= 1.5;
            vz *= 1.5;
          }
        } else if (e.type === 2) {
          // tank - yavaş ama push
          const side = normalize2(-dir.z, dir.x);
          const sway = Math.sin(elapsedTime * 2 + i) * 0.5;
          vx += side.x * e.speed * 0.4 * sway;
          vz += side.z * e.speed * 0.4 * sway;
        } else if (e.type === 3) {
          // turret - belli mesafede dur ve ateş et
          if (dist > 18) {
            vx *= 1.3;
            vz *= 1.3;
          } else if (dist < 10) {
            vx *= -0.8;
            vz *= -0.8;
          } else {
            vx = 0;
            vz = 0;
          }

          e.fireCooldown -= dt;
          if (e.fireCooldown <= 0 && dist < 45) {
            spawnBullet(dx, dz, false, { x: e.x, z: e.z }, 26);
            e.fireCooldown = 2.2 + Math.random() * 1.2;
          }
        }

        e.x += vx * dt;
        e.z += vz * dt;

        e.x = clamp(e.x, -WORLD_SIZE / 2 + 3, WORLD_SIZE / 2 - 3);
        e.z = clamp(e.z, -WORLD_SIZE / 2 + 3, WORLD_SIZE / 2 - 3);

        e.mesh.position.set(e.x, e.y, e.z);

        const dPlayer = Math.hypot(player.x - e.x, player.z - e.z);
        if (dPlayer < player.radius + e.radius) {
          player.hp -= e.damage * dt;
          if (player.hp <= 0) {
            player.hp = 0;
            playHit();
            onGameOver();
            return;
          }
        }

        if (e.hp <= 0) {
          killEnemy(i);
        }
      }
    }

    function updateBullets(dt) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx * dt;
        b.z += b.vz * dt;
        b.life -= dt;
        b.mesh.position.set(b.x, 1.1, b.z);

        if (
          Math.abs(b.x) > WORLD_SIZE / 2 + 8 ||
          Math.abs(b.z) > WORLD_SIZE / 2 + 8 ||
          b.life <= 0
        ) {
          scene.remove(b.mesh);
          bullets.splice(i, 1);
          continue;
        }

        if (b.fromPlayer) {
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            const d = Math.hypot(e.x - b.x, e.z - b.z);
            if (d < e.radius + b.radius) {
              let dmg = player.damage;
              if (player.critChance && Math.random() < player.critChance) {
                dmg *= 1.8;
              }
              e.hp -= dmg;
              playHit();
              scene.remove(b.mesh);
              bullets.splice(i, 1);
              if (e.hp <= 0) {
                killEnemy(j);
              }
              break;
            }
          }
        } else {
          // düşman mermileri
          const d = Math.hypot(player.x - b.x, player.z - b.z);
          if (d < player.radius + b.radius) {
            player.hp -= 14;
            playHit();
            scene.remove(b.mesh);
            bullets.splice(i, 1);
            if (player.hp <= 0) {
              player.hp = 0;
              onGameOver();
            }
          }
        }
      }
    }

    function updateXpOrbs(dt) {
      for (let i = xpOrbs.length - 1; i >= 0; i--) {
        const orb = xpOrbs[i];
        const dx = player.x - orb.x;
        const dz = player.z - orb.z;
        const dist = Math.hypot(dx, dz);

        if (dist < player.pickupRadius) {
          const pull = 12 * dt;
          const n = normalize2(dx, dz);
          orb.x += n.x * pull;
          orb.z += n.z * pull;
          orb.mesh.position.set(orb.x, 0.7, orb.z);
        }

        if (dist < player.radius + orb.radius) {
          xp += orb.value;
          playPickup();
          scene.remove(orb.mesh);
          xpOrbs.splice(i, 1);

          while (xp >= xpNeeded) {
            xp -= xpNeeded;
            level++;
            xpNeeded = Math.floor(10 + level * 6);
            queueLevelUp();
          }
        }
      }
    }

    function autoShoot(dt) {
      shootCooldown -= dt;
      if (shootCooldown > 0) return;
      if (enemies.length === 0) return;

      let nearest = null;
      let best = Infinity;
      for (const e of enemies) {
        const d = Math.hypot(e.x - player.x, e.z - player.z);
        if (d < best) {
          best = d;
          nearest = e;
        }
      }
      if (!nearest) return;

      spawnBullet(nearest.x - player.x, nearest.z - player.z, true);
      shootCooldown = 1 / player.fireRate;
    }

    function updateHud() {
      hudHp.textContent = `${Math.round(player.hp)} / ${player.maxHp}`;
      hudLevel.textContent = level.toString();
      hudKills.textContent = killCount.toString();
      hudTime.textContent = formatTime(elapsedTime);

      const pct = clamp((xp / xpNeeded) * 100, 0, 100);
      xpFill.style.width = pct + "%";
      xpText.textContent = `XP ${Math.floor(xp)} / ${xpNeeded}`;
    }

    function updateCamera(dt) {
      const target = new THREE.Vector3(player.x, 42, player.z + 50);
      camera.position.lerp(target, cameraFollowSmooth);
      camera.lookAt(player.x, 0, player.z);
    }

    function update(dt) {
      elapsedTime += dt;

      // Enemy spawn
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        spawnEnemy();
        const base = 1.8 - elapsedTime * 0.008;
        spawnTimer = Math.max(0.7, base + Math.random() * 0.7);
      }

      updatePlayer(dt);
      updateEnemies(dt);
      updateBullets(dt);
      updateXpOrbs(dt);
      autoShoot(dt);
      updateHud();
      updateCamera(dt);
    }

    // === LOOP ===
    function loop(now) {
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      if (gameState === "playing" && !isPausedForUpgrade) {
        update(dt);
      }

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    // === GAME STATE ===
    function onGameOver() {
      if (gameState !== "playing") return;
      gameState = "gameover";
      isPausedForUpgrade = false;
      pendingLevelUps = 0;

      statTime.textContent = formatTime(elapsedTime);
      statKills.textContent = killCount.toString();
      statLevel.textContent = level.toString();

      upgradeScreen.classList.remove("visible");
      upgradeScreen.style.display = "none";

      gameoverScreen.style.display = "flex";
      requestAnimationFrame(() => {
        gameoverScreen.classList.add("visible");
      });
    }

    // === INPUT: KEYBOARD ===
    window.addEventListener("keydown", (e) => {
      if (e.code === "KeyW" || e.code === "ArrowUp") keyState.up = true;
      if (e.code === "KeyS" || e.code === "ArrowDown") keyState.down = true;
      if (e.code === "KeyA" || e.code === "ArrowLeft") keyState.left = true;
      if (e.code === "KeyD" || e.code === "ArrowRight") keyState.right = true;
    });

    window.addEventListener("keyup", (e) => {
      if (e.code === "KeyW" || e.code === "ArrowUp") keyState.up = false;
      if (e.code === "KeyS" || e.code === "ArrowDown") keyState.down = false;
      if (e.code === "KeyA" || e.code === "ArrowLeft") keyState.left = false;
      if (e.code === "KeyD" || e.code === "ArrowRight") keyState.right = false;
    });

    // === INPUT: JOYSTICK ===
    function getPos(event, element) {
      const rect = element.getBoundingClientRect();
      const clientX = event.touches ? event.touches[0].clientX : event.clientX;
      const clientY = event.touches ? event.touches[0].clientY : event.clientY;
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function joystickStart(event) {
      event.preventDefault();
      joystickActive = true;
      const rect = joystickBase.getBoundingClientRect();
      joystickCenter.x = rect.width / 2;
      joystickCenter.y = rect.height / 2;
      joystickMove(event);
    }

    function joystickMove(event) {
      if (!joystickActive) return;
      event.preventDefault();
      const pos = getPos(event, joystickBase);
      const dx = pos.x - joystickCenter.x;
      const dy = pos.y - joystickCenter.y;
      const maxDist = joystickBase.clientWidth / 2 - 10;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;

      let nx = dx;
      let ny = dy;
      if (dist > maxDist) {
        const ratio = maxDist / dist;
        nx *= ratio;
        ny *= ratio;
      }

      joystickKnob.style.transform =
        `translate(${nx}px, ${ny}px) translate(-50%, -50%)`;

      const normX = nx / maxDist;
      const normY = ny / maxDist;

      joystickVec.x = normX;
      joystickVec.z = normY; // yukarı negatif, aşağı pozitif -> Z ekseni
    }

    function joystickEnd(event) {
      event && event.preventDefault();
      joystickActive = false;
      joystickVec.x = 0;
      joystickVec.z = 0;
      joystickKnob.style.transform = "translate(-50%, -50%)";
    }

    joystickBase.addEventListener("pointerdown", joystickStart);
    window.addEventListener("pointermove", joystickMove);
    window.addEventListener("pointerup", joystickEnd);
    window.addEventListener("pointercancel", joystickEnd);

    // === BUTONLAR ===
    soundToggle.addEventListener("change", () => {
      soundEnabled = soundToggle.checked;
      if (soundEnabled && gameState === "playing") {
        initAudio();
      }
    });

    btnStart.addEventListener("click", () => {
      soundEnabled = soundToggle.checked;
      if (soundEnabled) initAudio();

      startScreen.classList.remove("visible");
      setTimeout(() => { startScreen.style.display = "none"; }, 180);

      resetGame();
      gameState = "playing";
    });

    btnRestart.addEventListener("click", () => {
      gameoverScreen.classList.remove("visible");
      setTimeout(() => { gameoverScreen.style.display = "none"; }, 180);
      resetGame();
      gameState = "playing";
    });

    btnQuit.addEventListener("click", () => {
      gameoverScreen.classList.remove("visible");
      setTimeout(() => { gameoverScreen.style.display = "none"; }, 180);
      gameState = "start";
      startScreen.style.display = "flex";
      requestAnimationFrame(() => {
        startScreen.classList.add("visible");
      });
    });

    // === BAŞLAT ===
    initThree();
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
