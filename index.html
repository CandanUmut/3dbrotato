<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Nova Arena 3D · Rogue Survivor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --panel: rgba(15, 23, 42, 0.96);
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.18);
      --danger: #ef4444;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --border: #1f2937;
      --radius: 14px;
      --shadow: 0 18px 40px rgba(0, 0, 0, 0.8);
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #0b1120 0, #020617 45%, #000 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #game-root {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    #ui-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      pointer-events: none;
      font-size: 13px;
    }

    .hud-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .hud-pill {
      pointer-events: auto;
      background: var(--panel);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      padding: 4px 10px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(10px);
    }

    .hud-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
    }

    .hud-value {
      font-weight: 600;
    }

    /* XP bar */
    #xp-wrapper {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 10px;
      width: min(75%, 680px);
      background: var(--panel);
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      overflow: hidden;
      pointer-events: auto;
    }

    #xp-inner {
      position: relative;
      width: 100%;
      height: 16px;
      background: #020617;
    }

    #xp-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      background: linear-gradient(90deg, #38bdf8, #22c55e);
      box-shadow: 0 0 20px rgba(56, 189, 248, 1);
      transition: width 0.18s linear;
    }

    #xp-text {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: #e5e7eb;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.9);
      pointer-events: none;
    }

    /* Screens */
    .screen {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .screen-card {
      min-width: min(400px, 90%);
      max-width: 480px;
      background: radial-gradient(circle at top left, var(--accent-soft), var(--panel));
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      box-shadow: var(--shadow);
      padding: 18px 18px 14px;
      transform: translateY(16px) scale(0.97);
      opacity: 0;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    }

    .screen.visible .screen-card {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .screen-title {
      font-size: 20px;
      font-weight: 700;
      margin: 0 0 4px;
    }

    .screen-sub {
      font-size: 13px;
      color: var(--text-soft);
      margin: 0 0 10px;
    }

    .screen-actions {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      background: var(--panel);
      padding: 6px 12px;
      font-size: 13px;
      color: var(--text);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background 0.16s ease-out, transform 0.16s ease-out, box-shadow 0.16s ease-out;
    }

    .btn:hover {
      background: #020617;
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.8);
    }

    .btn-primary {
      background: linear-gradient(135deg, #38bdf8, #22c55e);
      border-color: transparent;
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 10px 26px rgba(56, 189, 248, 0.9);
    }

    .btn-primary:hover {
      box-shadow: 0 14px 30px rgba(56, 189, 248, 1);
    }

    .btn-ghost-danger {
      border-color: rgba(248, 113, 113, 0.9);
      color: #fecaca;
    }

    .screen-row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-soft);
      margin-bottom: 3px;
    }

    .screen-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-soft);
      margin-top: 6px;
    }

    .screen-toggle input {
      accent-color: #22c55e;
    }

    /* Upgrade screen */
    #upgrade-screen {
      display: none;
    }

    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .upgrade-card {
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      background: rgba(15, 23, 42, 0.9);
      padding: 8px;
      cursor: pointer;
      transition: transform 0.15s ease-out, box-shadow 0.15s ease-out, border-color 0.15s ease-out, background 0.15s ease-out;
      font-size: 12px;
    }

    .upgrade-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 24px rgba(56, 189, 248, 0.6);
      border-color: #38bdf8;
      background: radial-gradient(circle at top left, rgba(56,189,248,0.12), rgba(15,23,42,0.95));
    }

    .upgrade-name {
      font-weight: 600;
      margin-bottom: 2px;
      font-size: 13px;
    }

    .upgrade-tag {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #4ade80;
      margin-bottom: 4px;
    }

    .upgrade-desc {
      font-size: 11px;
      color: var(--text-soft);
    }

    /* Hint */
    #hint {
      position: absolute;
      left: 8px;
      bottom: 12px;
      font-size: 11px;
      color: var(--text-soft);
      pointer-events: none;
    }

    /* Joystick */
    #joystick-wrapper {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      width: 130px;
      height: 130px;
      pointer-events: none;
      touch-action: none;
    }

    #joystick-base {
      position: absolute;
      inset: 0;
      margin: auto;
      width: 110px;
      height: 110px;
      border-radius: 50%;
      border: 1px solid rgba(148, 163, 184, 0.9);
      background: radial-gradient(circle at center, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.85));
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.9);
      pointer-events: auto;
    }

    #joystick-knob {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at top, #38bdf8, #0f172a);
      border: 1px solid rgba(148, 163, 184, 1);
      box-shadow: 0 10px 25px rgba(56, 189, 248, 0.9);
      touch-action: none;
    }

    /* Jump button (mobil) */
    #btn-jump {
      position: absolute;
      right: 18px;
      bottom: 26px;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 1px solid rgba(148, 163, 184, 0.9);
      background: radial-gradient(circle at top, #22c55e, #14532d);
      color: #e5e7eb;
      font-weight: 700;
      font-size: 20px;
      box-shadow: 0 10px 30px rgba(34, 197, 94, 0.9);
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    #btn-jump:active {
      transform: translateY(2px) scale(0.97);
      box-shadow: 0 6px 16px rgba(34, 197, 94, 0.8);
    }

    @media (max-width: 768px) {
      #xp-wrapper {
        width: 92%;
      }
      .hud-pill {
        padding: 3px 8px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      * {
        transition: none !important;
        animation: none !important;
      }
    }
  </style>
</head>
<body>
  <div id="game-root"></div>

  <div id="ui-overlay">
    <!-- HUD -->
    <div id="hud">
      <div class="hud-group">
        <div class="hud-pill">
          <span class="hud-label">HP</span>
          <span class="hud-value" id="hud-hp">100 / 100</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">LEVEL</span>
          <span class="hud-value" id="hud-level">1</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">KILLS</span>
          <span class="hud-value" id="hud-kills">0</span>
        </div>
      </div>
      <div class="hud-group">
        <div class="hud-pill">
          <span class="hud-label">TIME</span>
          <span class="hud-value" id="hud-time">00:00</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">BUILD</span>
          <span class="hud-value" id="hud-build">3D Terrain</span>
        </div>
      </div>
    </div>

    <!-- XP bar -->
    <div id="xp-wrapper">
      <div id="xp-inner">
        <div id="xp-fill"></div>
        <div id="xp-text">XP 0 / 10</div>
      </div>
    </div>

    <!-- Hint -->
    <div id="hint">
      PC: WASD / ok tuşları, fareyi sürükleyerek etrafa bak · Space: zıpla<br/>
      Mobil: sol ortadaki joystick + sağ alttaki zıplama butonu. Level-up olduğunda upgrade seç.
    </div>

    <!-- Start screen -->
    <div id="start-screen" class="screen visible">
      <div class="screen-card">
        <h1 class="screen-title">Nova Arena 3D</h1>
        <p class="screen-sub">
          Perlin noise ile üretilmiş bir arazide, gece-gündüz döngüsü altında hayatta kal.
          Etrafına bak, zıpla, bacaklı düşman sürülerini temizle ve build'ini güçlendir.
        </p>
        <div class="screen-toggle">
          <label>
            <input type="checkbox" id="sound-toggle" checked />
            Ses efektleri aktif olsun
          </label>
        </div>
        <div class="screen-actions">
          <button id="btn-start" class="btn btn-primary">▶ Başlat</button>
        </div>
      </div>
    </div>

    <!-- Game Over -->
    <div id="gameover-screen" class="screen" style="display:none;">
      <div class="screen-card">
        <h2 class="screen-title">Oyun Bitti</h2>
        <p class="screen-sub">
          Güzel bir run oldu. İstersen farklı upgrade kombinasyonları deneyerek tekrar oyna.
        </p>
        <div class="screen-row">
          <span>Toplam süre</span><span id="stat-time">00:00</span>
        </div>
        <div class="screen-row">
          <span>Öldürülen düşman</span><span id="stat-kills">0</span>
        </div>
        <div class="screen-row">
          <span>Ulaşılan seviye</span><span id="stat-level">1</span>
        </div>
        <div class="screen-actions">
          <button id="btn-restart" class="btn btn-primary">↻ Tekrar Oyna</button>
          <button id="btn-quit" class="btn btn-ghost-danger">⏻ Çık</button>
        </div>
      </div>
    </div>

    <!-- Upgrade screen -->
    <div id="upgrade-screen" class="screen">
      <div class="screen-card">
        <h2 class="screen-title">Level Up!</h2>
        <p class="screen-sub">
          Bir upgrade seç, build'ini şekillendir:
        </p>
        <div id="upgrade-options" class="upgrade-grid"></div>
      </div>
    </div>

    <!-- Mobile joystick -->
    <div id="joystick-wrapper">
      <div id="joystick-base">
        <div id="joystick-knob"></div>
      </div>
    </div>

    <!-- Jump button (mobile) -->
    <button id="btn-jump">⤴</button>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // === TEMEL SABİTLER / DURUM ===
    const WORLD_SIZE = 260;

    let scene, camera, renderer;
    let lastTime = performance.now();
    let gameState = "start";
    let isPausedForUpgrade = false;

    // Kamera & gün döngüsü
    let cameraFollowSmooth = 0.12;
    let cameraYaw = Math.PI; // etrafa bakma için
    let isDraggingCam = false;
    let lastCamX = 0;
    let dayTime = 0;
    const DAY_LENGTH = 120; // saniye

    // Aydınlatma ve gökyüzü
    let ambientLight, sunLight, starMaterial;

    // Perlin noise
    const Perlin = (() => {
      const permutation = [];
      for (let i = 0; i < 256; i++) permutation[i] = i;
      // shuffle
      for (let i = 255; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
      }
      const p = new Uint8Array(512);
      for (let i = 0; i < 512; i++) p[i] = permutation[i & 255];

      function fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }
      function lerp(t, a, b) {
        return a + t * (b - a);
      }
      function grad(hash, x, y) {
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
      }
      function noise(x, y) {
        let X = Math.floor(x) & 255;
        let Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = fade(x);
        const v = fade(y);
        const A = p[X] + Y;
        const B = p[X + 1] + Y;
        return lerp(
          v,
          lerp(u, grad(p[A], x, y), grad(p[B], x - 1, y)),
          lerp(u, grad(p[A + 1], x, y - 1), grad(p[B + 1], x - 1, y - 1))
        );
      }
      return { noise };
    })();

    function terrainHeight(x, z) {
      const s1 = 0.03;
      const s2 = 0.08;
      const h1 = Perlin.noise(x * s1, z * s1) * 4;
      const h2 = Perlin.noise(x * s2 + 100, z * s2 + 100) * 2;
      return h1 + h2 - 4; // biraz aşağı shift
    }

    const player = {
      x: 0,
      z: 0,
      y: 2,
      radius: 1.3,
      speed: 18,
      hp: 100,
      maxHp: 100,
      regen: 0,
      damage: 26,
      fireRate: 2.6,
      bulletSpeed: 42,
      bulletLife: 3,
      pickupRadius: 7.5,
      mesh: null,
      vy: 0,
      jumpOffset: 0,
      onGround: true
    };

    const enemies = [];
    const bullets = [];
    const xpOrbs = [];

    let elapsedTime = 0;
    let killCount = 0;
    let level = 1;
    let xp = 0;
    let xpNeeded = 10;
    let spawnTimer = 0;
    let shootCooldown = 0;
    let pendingLevelUps = 0;

    const keyState = { up: false, down: false, left: false, right: false };

    // Audio
    let audioCtx = null;
    let soundEnabled = true;

    function initAudio() {
      if (!soundEnabled || audioCtx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      audioCtx = new AC();
      audioCtx.resume && audioCtx.resume();
    }

    function playBeep(freq, duration, volume) {
      if (!audioCtx || !soundEnabled) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function playShoot() {
      playBeep(780, 0.09, 0.4);
    }
    function playPickup() {
      playBeep(540, 0.12, 0.45);
    }
    function playHit() {
      playBeep(160, 0.1, 0.5);
    }
    function playLevelUp() {
      playBeep(880, 0.14, 0.55);
      setTimeout(() => playBeep(1180, 0.14, 0.5), 90);
    }
    function playJump() {
      playBeep(660, 0.08, 0.4);
    }

    // UI elemanları
    const hudHp = document.getElementById("hud-hp");
    const hudLevel = document.getElementById("hud-level");
    const hudKills = document.getElementById("hud-kills");
    const hudTime = document.getElementById("hud-time");
    const hudBuild = document.getElementById("hud-build");

    const xpFill = document.getElementById("xp-fill");
    const xpText = document.getElementById("xp-text");

    const startScreen = document.getElementById("start-screen");
    const gameoverScreen = document.getElementById("gameover-screen");
    const upgradeScreen = document.getElementById("upgrade-screen");
    const upgradeOptions = document.getElementById("upgrade-options");

    const soundToggle = document.getElementById("sound-toggle");
    const btnStart = document.getElementById("btn-start");
    const btnRestart = document.getElementById("btn-restart");
    const btnQuit = document.getElementById("btn-quit");
    const btnJump = document.getElementById("btn-jump");

    const statTime = document.getElementById("stat-time");
    const statKills = document.getElementById("stat-kills");
    const statLevel = document.getElementById("stat-level");

    // Joystick
    const joystickBase = document.getElementById("joystick-base");
    const joystickKnob = document.getElementById("joystick-knob");
    let joystickActive = false;
    let joystickCenter = { x: 0, y: 0 };
    let joystickVec = { x: 0, z: 0 };

    // Upgrades
    let currentUpgradeChoices = [];

    const ALL_UPGRADES = [
      {
        id: "fire_rate_1",
        name: "Rapid Fire",
        tag: "Attack",
        desc: "Ateş hızın %30 artar.",
        apply() { player.fireRate *= 1.3; }
      },
      {
        id: "fire_rate_2",
        name: "Bullet Storm",
        tag: "Attack",
        desc: "Ateş hızın %20 artar, mermi ömrü +1s.",
        apply() { player.fireRate *= 1.2; player.bulletLife += 1; }
      },
      {
        id: "damage_1",
        name: "Power Shot",
        tag: "Attack",
        desc: "Hasarın %35 artar.",
        apply() { player.damage *= 1.35; }
      },
      {
        id: "damage_2",
        name: "Critical Core",
        tag: "Attack",
        desc: "Hasarın %20 artar, kritik ihtimali eklenir.",
        apply() { player.damage *= 1.2; player.critChance = (player.critChance || 0) + 0.15; }
      },
      {
        id: "hp_1",
        name: "Titan Shell",
        tag: "Defense",
        desc: "Max HP +35, anında +25 HP.",
        apply() { player.maxHp += 35; player.hp = Math.min(player.maxHp, player.hp + 25); }
      },
      {
        id: "regen_1",
        name: "Nanobot Regen",
        tag: "Defense",
        desc: "Saniyede +1.8 HP yenilenme.",
        apply() { player.regen += 1.8; }
      },
      {
        id: "speed_1",
        name: "Vector Boots",
        tag: "Utility",
        desc: "Hareket hızın %25 artar.",
        apply() { player.speed *= 1.25; }
      },
      {
        id: "pickup_1",
        name: "Magnet Core",
        tag: "Utility",
        desc: "XP toplama yarıçapın %40 artar.",
        apply() { player.pickupRadius *= 1.4; }
      },
      {
        id: "control_1",
        name: "Drift Thrusters",
        tag: "Utility",
        desc: "Kamera takibi ve kontrol daha yumuşak.",
        apply() { cameraFollowSmooth = 0.16; }
      }
    ];

    // Yardımcılar
    function clamp(v, min, max) {
      return v < min ? min : v > max ? max : v;
    }

    function formatTime(t) {
      const total = Math.floor(t);
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
    }

    function normalize2(x, z) {
      const len = Math.hypot(x, z) || 1;
      return { x: x / len, z: z / len };
    }

    function sampleUpgrades(n) {
      const pool = ALL_UPGRADES.slice();
      const choices = [];
      for (let i = 0; i < n && pool.length > 0; i++) {
        const idx = (Math.random() * pool.length) | 0;
        choices.push(pool.splice(idx, 1)[0]);
      }
      return choices;
    }

    function queueLevelUp() {
      pendingLevelUps++;
      if (!isPausedForUpgrade && gameState === "playing") {
        openUpgradeChoice();
      }
    }

    function openUpgradeChoice() {
      if (pendingLevelUps <= 0) return;
      isPausedForUpgrade = true;
      pendingLevelUps--;

      playLevelUp();

      currentUpgradeChoices = sampleUpgrades(3);
      upgradeOptions.innerHTML = "";

      currentUpgradeChoices.forEach((upg) => {
        const card = document.createElement("div");
        card.className = "upgrade-card";
        card.innerHTML = `
          <div class="upgrade-tag">${upg.tag}</div>
          <div class="upgrade-name">${upg.name}</div>
          <div class="upgrade-desc">${upg.desc}</div>
        `;
        card.addEventListener("click", () => {
          upg.apply();
          closeUpgradeScreen();
        });
        upgradeOptions.appendChild(card);
      });

      upgradeScreen.style.display = "flex";
      requestAnimationFrame(() => {
        upgradeScreen.classList.add("visible");
      });
    }

    function closeUpgradeScreen() {
      upgradeScreen.classList.remove("visible");
      setTimeout(() => {
        upgradeScreen.style.display = "none";
        isPausedForUpgrade = false;
        if (pendingLevelUps > 0 && gameState === "playing") {
          openUpgradeChoice();
        }
      }, 150);
    }

    // === THREE SAHNE ===
    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x020617);
      scene.fog = new THREE.FogExp2(0x020617, 0.015);

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        800
      );
      camera.position.set(0, 50, 60);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.getElementById("game-root").appendChild(renderer.domElement);

      // Işıklar
      ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);

      sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
      sunLight.position.set(40, 70, 20);
      sunLight.castShadow = false;
      scene.add(sunLight);

      const rimLight = new THREE.DirectionalLight(0x38bdf8, 0.6);
      rimLight.position.set(-60, 40, -40);
      scene.add(rimLight);

      // Arazi
      createTerrain();

      // Yıldızlar
      createStarField();

      // Player
      createPlayer();

      // Kamera drag
      renderer.domElement.addEventListener("pointerdown", (e) => {
        if (e.button !== 0) return;
        // UI'ye tıklamadığından emin ol
        if (e.target !== renderer.domElement) return;
        isDraggingCam = true;
        lastCamX = e.clientX;
      });
      window.addEventListener("pointermove", (e) => {
        if (!isDraggingCam) return;
        const dx = e.clientX - lastCamX;
        lastCamX = e.clientX;
        cameraYaw -= dx * 0.004;
      });
      window.addEventListener("pointerup", () => {
        isDraggingCam = false;
      });
      window.addEventListener("pointercancel", () => {
        isDraggingCam = false;
      });

      window.addEventListener("resize", onWindowResize);
    }

    function createTerrain() {
      const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 80, 80);
      const pos = groundGeo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const z = pos.getZ(i);
        const y = terrainHeight(x, z);
        pos.setY(i, y);
      }
      pos.needsUpdate = true;
      groundGeo.computeVertexNormals();

      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x14532d,
        metalness: 0.25,
        roughness: 0.9,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Hafif grid overlay (yüksekliğe bakmadan)
      const grid = new THREE.GridHelper(WORLD_SIZE, 40, 0x38bdf8, 0x111827);
      grid.position.y = 0.1;
      scene.add(grid);
    }

    function createStarField() {
      const starCount = 900;
      const positions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        positions[i * 3 + 0] = (Math.random() - 0.5) * 480;
        positions[i * 3 + 1] = 60 + Math.random() * 180;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 480;
      }
      const starGeo = new THREE.BufferGeometry();
      starGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.1,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.9
      });
      const stars = new THREE.Points(starGeo, starMaterial);
      scene.add(stars);
    }

    function createPlayer() {
      const group = new THREE.Group();

      // Gövde (kapsül)
      const bodyGeo = new THREE.CylinderGeometry(0.9, 0.9, 3.6, 18);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0x38bdf8,
        emissive: 0x1d4ed8,
        emissiveIntensity: 0.9,
        roughness: 0.35,
        metalness: 0.7,
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      group.add(body);

      // Kafa
      const headGeo = new THREE.SphereGeometry(1.1, 20, 20);
      const headMat = new THREE.MeshStandardMaterial({
        color: 0x22c55e,
        emissive: 0x22c55e,
        emissiveIntensity: 1,
        metalness: 0.4,
        roughness: 0.3,
      });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 2.3;
      group.add(head);

      // Thruster
      const thrusterGeo = new THREE.ConeGeometry(0.9, 1.6, 16);
      const thrusterMat = new THREE.MeshStandardMaterial({
        color: 0xf97316,
        emissive: 0xf97316,
        emissiveIntensity: 0.8,
        metalness: 0.6,
        roughness: 0.4,
      });
      const thruster = new THREE.Mesh(thrusterGeo, thrusterMat);
      thruster.position.y = -2.2;
      thruster.rotation.x = Math.PI;
      group.add(thruster);

      // Kanatlar
      const wingGeo = new THREE.BoxGeometry(0.4, 1.8, 3.6);
      const wingMat = new THREE.MeshStandardMaterial({
        color: 0x0ea5e9,
        emissive: 0x0ea5e9,
        emissiveIntensity: 0.6,
        metalness: 0.7,
        roughness: 0.4,
      });
      const wingL = new THREE.Mesh(wingGeo, wingMat);
      wingL.position.set(-1.2, 0.2, 0);
      const wingR = wingL.clone();
      wingR.position.x = 1.2;
      group.add(wingL, wingR);

      const light = new THREE.PointLight(0x38bdf8, 1.5, 22);
      light.position.set(0, 3, 0);
      group.add(light);

      const groundY = terrainHeight(0, 0);
      group.position.set(0, groundY + 2.2, 0);
      group.rotation.y = Math.PI;
      scene.add(group);

      player.x = 0;
      player.z = 0;
      player.y = groundY + 2.2;
      player.mesh = group;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // === DÜŞMAN MODELLEME ===
    function createEnemyMesh(type) {
      const g = new THREE.Group();
      let radius = 1.3;

      if (type === 0) {
        // Walker (insansı, 2 bacak)
        const torsoGeo = new THREE.BoxGeometry(1, 1.8, 0.8);
        const torsoMat = new THREE.MeshStandardMaterial({
          color: 0xf97316,
          emissive: 0xf97316,
          emissiveIntensity: 0.6,
          roughness: 0.4,
          metalness: 0.5,
        });
        const torso = new THREE.Mesh(torsoGeo, torsoMat);
        torso.position.y = 2;
        g.add(torso);

        const headGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const head = new THREE.Mesh(headGeo, torsoMat);
        head.position.y = 2.9;
        g.add(head);

        const legGeo = new THREE.BoxGeometry(0.4, 1.4, 0.4);
        const legL = new THREE.Mesh(legGeo, torsoMat);
        legL.position.set(-0.35, 1.1, 0);
        const legR = legL.clone();
        legR.position.x = 0.35;
        g.add(legL, legR);

        radius = 1.3;
      } else if (type === 1) {
        // Crawler (4 ayaklı yaratık)
        const bodyGeo = new THREE.BoxGeometry(1.8, 0.8, 1.2);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: 0x22c55e,
          emissive: 0x22c55e,
          emissiveIntensity: 0.7,
          roughness: 0.4,
          metalness: 0.5,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 1.2;
        g.add(body);

        const headGeo = new THREE.SphereGeometry(0.6, 14, 14);
        const head = new THREE.Mesh(headGeo, bodyMat);
        head.position.set(0, 1.5, 0.9);
        g.add(head);

        const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 1, 8);
        const legMat = new THREE.MeshStandardMaterial({
          color: 0x166534,
          emissive: 0x16a34a,
          emissiveIntensity: 0.5,
        });
        const offsets = [
          [-0.7, 0.7],
          [0.7, 0.7],
          [-0.7, -0.7],
          [0.7, -0.7],
        ];
        offsets.forEach(([x, z]) => {
          const leg = new THREE.Mesh(legGeo, legMat);
          leg.position.set(x, 0.7, z);
          g.add(leg);
        });

        radius = 1.4;
      } else if (type === 2) {
        // Sentinel (uzun gözetleyici)
        const baseGeo = new THREE.CylinderGeometry(0.7, 1.2, 2.6, 12);
        const baseMat = new THREE.MeshStandardMaterial({
          color: 0x6366f1,
          emissive: 0x4f46e5,
          emissiveIntensity: 0.9,
          roughness: 0.35,
          metalness: 0.7,
        });
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.position.y = 1.5;
        g.add(base);

        const headGeo = new THREE.SphereGeometry(0.9, 20, 20);
        const head = new THREE.Mesh(headGeo, baseMat);
        head.position.y = 2.8;
        g.add(head);

        const armGeo = new THREE.BoxGeometry(0.3, 1.2, 0.3);
        const armL = new THREE.Mesh(armGeo, baseMat);
        armL.position.set(-0.9, 2.2, 0);
        const armR = armL.clone();
        armR.position.x = 0.9;
        g.add(armL, armR);

        radius = 1.2;
      } else {
        // Hopper (küçük zıplayan böcek)
        const bodyGeo = new THREE.SphereGeometry(0.9, 14, 14);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: 0x0ea5e9,
          emissive: 0x0ea5e9,
          emissiveIntensity: 0.8,
          roughness: 0.4,
          metalness: 0.6,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 1.4;
        g.add(body);

        const legGeo = new THREE.ConeGeometry(0.25, 0.9, 8);
        const legMat = new THREE.MeshStandardMaterial({
          color: 0x0369a1,
          emissive: 0x0369a1,
          emissiveIntensity: 0.7,
        });
        const legL = new THREE.Mesh(legGeo, legMat);
        legL.position.set(-0.45, 0.7, 0.4);
        legL.rotation.z = Math.PI / 2.4;
        const legR = legL.clone();
        legR.position.x = 0.45;
        g.add(legL, legR);

        radius = 1.0;
      }

      return { mesh: g, radius };
    }

    // === GAME RESET ===
    function resetGame() {
      enemies.forEach(e => scene.remove(e.mesh));
      bullets.forEach(b => scene.remove(b.mesh));
      xpOrbs.forEach(o => scene.remove(o.mesh));
      enemies.length = 0;
      bullets.length = 0;
      xpOrbs.length = 0;

      player.x = 0;
      player.z = 0;
      player.jumpOffset = 0;
      player.vy = 0;
      player.onGround = true;
      player.hp = 100;
      player.maxHp = 100;
      player.regen = 0;
      player.damage = 26;
      player.fireRate = 2.6;
      player.bulletSpeed = 42;
      player.bulletLife = 3;
      player.pickupRadius = 7.5;
      player.critChance = 0;

      const groundY = terrainHeight(player.x, player.z);
      player.y = groundY + 2.2;
      if (player.mesh) {
        player.mesh.position.set(player.x, player.y, player.z);
      }

      elapsedTime = 0;
      killCount = 0;
      level = 1;
      xp = 0;
      xpNeeded = 10;
      spawnTimer = 0.5;
      shootCooldown = 0;
      pendingLevelUps = 0;
      cameraFollowSmooth = 0.12;

      hudBuild.textContent = "3D Terrain";
    }

    // === ENEMIES / BULLETS / XP ===
    function spawnEnemy() {
      const angle = Math.random() * Math.PI * 2;
      const dist = 35 + Math.random() * 50;
      let x = player.x + Math.cos(angle) * dist;
      let z = player.z + Math.sin(angle) * dist;

      x = clamp(x, -WORLD_SIZE / 2 + 6, WORLD_SIZE / 2 - 6);
      z = clamp(z, -WORLD_SIZE / 2 + 6, WORLD_SIZE / 2 - 6);

      const t = Math.floor(Math.random() * 4);

      const { mesh, radius } = createEnemyMesh(t);
      const groundY = terrainHeight(x, z);
      mesh.position.set(x, groundY + 1.4, z);
      scene.add(mesh);

      const timeFactor = 1 + elapsedTime / 180;

      // Kolay kesilsin diye düşük HP
      let baseHp = 16 * timeFactor;
      let baseSpeed = 9;
      let damage = 8 * timeFactor;

      if (t === 1) { // crawler
        baseHp = 18 * timeFactor;
        baseSpeed = 11;
        damage = 9 * timeFactor;
      } else if (t === 2) { // sentinel
        baseHp = 20 * timeFactor;
        baseSpeed = 7;
        damage = 12 * timeFactor;
      } else if (t === 3) { // hopper
        baseHp = 12 * timeFactor;
        baseSpeed = 12;
        damage = 10 * timeFactor;
      }

      enemies.push({
        x,
        z,
        radius,
        speed: baseSpeed,
        hp: baseHp,
        maxHp: baseHp,
        damage,
        type: t,
        mesh,
        fireCooldown: 1.5 + Math.random(),
        hopTimer: 0
      });
    }

    function spawnBullet(dirX, dirZ, fromPlayer = true, origin = null, speedOverride = null) {
      const n = normalize2(dirX, dirZ);
      const geo = new THREE.SphereGeometry(fromPlayer ? 0.28 : 0.22, 10, 10);
      const mat = new THREE.MeshStandardMaterial({
        color: fromPlayer ? 0xfacc15 : 0x6366f1,
        emissive: fromPlayer ? 0xfacc15 : 0x6366f1,
        emissiveIntensity: 1,
        roughness: 0.3,
        metalness: 0.3,
      });
      const mesh = new THREE.Mesh(geo, mat);

      const startX = origin ? origin.x : player.x;
      const startZ = origin ? origin.z : player.z;
      const startY = origin
        ? terrainHeight(origin.x, origin.z) + 2
        : player.y;

      mesh.position.set(
        startX + n.x * 1.8,
        startY,
        startZ + n.z * 1.8
      );
      scene.add(mesh);

      const speed = speedOverride || player.bulletSpeed;

      bullets.push({
        x: mesh.position.x,
        z: mesh.position.z,
        vx: n.x * speed,
        vz: n.z * speed,
        radius: fromPlayer ? 0.3 : 0.25,
        life: fromPlayer ? player.bulletLife : 2.4,
        mesh,
        fromPlayer,
      });

      if (fromPlayer) playShoot();
    }

    function spawnXpOrb(x, z) {
      const geo = new THREE.SphereGeometry(0.35, 10, 10);
      const mat = new THREE.MeshStandardMaterial({
        color: 0x22c55e,
        emissive: 0x16a34a,
        emissiveIntensity: 1,
        roughness: 0.35,
      });
      const mesh = new THREE.Mesh(geo, mat);
      const groundY = terrainHeight(x, z);
      mesh.position.set(x, groundY + 0.7, z);
      scene.add(mesh);

      xpOrbs.push({
        x,
        z,
        radius: 0.4,
        value: 1 + Math.random(),
        mesh,
      });
    }

    function killEnemy(index) {
      const e = enemies[index];
      spawnXpOrb(e.x, e.z);
      scene.remove(e.mesh);
      enemies.splice(index, 1);
      killCount++;
    }

    // === UPDATE ===
    function tryJump() {
      if (!player.onGround || gameState !== "playing") return;
      player.vy = 18;
      player.onGround = false;
      playJump();
    }

    function updatePlayer(dt) {
      // Kamera bazlı yön
      const forwardVec = normalize2(
        player.x - camera.position.x,
        player.z - camera.position.z
      );
      const rightVec = { x: -forwardVec.z, z: forwardVec.x };

      let localX = 0;
      let localZ = 0;
      if (keyState.left) localX -= 1;
      if (keyState.right) localX += 1;
      if (keyState.up) localZ += 1;
      if (keyState.down) localZ -= 1;

      // Joystick'i de ekle
      localX += joystickVec.x;
      localZ += joystickVec.z;

      if (localX !== 0 || localZ !== 0) {
        const len = Math.hypot(localX, localZ) || 1;
        localX /= len;
        localZ /= len;

        const moveXWorld = forwardVec.x * localZ + rightVec.x * localX;
        const moveZWorld = forwardVec.z * localZ + rightVec.z * localX;

        player.x += moveXWorld * player.speed * dt;
        player.z += moveZWorld * player.speed * dt;

        const angle = Math.atan2(moveXWorld, moveZWorld);
        if (player.mesh) player.mesh.rotation.y = angle;
      }

      player.x = clamp(player.x, -WORLD_SIZE / 2 + 3, WORLD_SIZE / 2 - 3);
      player.z = clamp(player.z, -WORLD_SIZE / 2 + 3, WORLD_SIZE / 2 - 3);

      // Zıplama / yer çekimi
      const groundY = terrainHeight(player.x, player.z) + 2.2;
      player.vy -= 36 * dt;
      player.jumpOffset += player.vy * dt;

      if (groundY + player.jumpOffset <= groundY) {
        player.jumpOffset = 0;
        player.vy = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }

      player.y = groundY + player.jumpOffset;

      if (player.mesh) {
        player.mesh.position.set(player.x, player.y, player.z);
      }

      if (player.regen > 0) {
        player.hp = clamp(player.hp + player.regen * dt, 0, player.maxHp);
      }
    }

    function updateEnemies(dt) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = player.x - e.x;
        const dz = player.z - e.z;
        const dist = Math.hypot(dx, dz) || 1;
        let dir = normalize2(dx, dz);

        let vx = dir.x * e.speed;
        let vz = dir.z * e.speed;

        if (e.type === 0) {
          // Walker: insansı, yaklaşırken hafif zigzag
          const side = normalize2(-dir.z, dir.x);
          const sway = Math.sin(elapsedTime * 4 + i) * 0.6;
          vx += side.x * e.speed * 0.4 * sway;
          vz += side.z * e.speed * 0.4 * sway;
        } else if (e.type === 1) {
          // Crawler: hızlı, düz koşar
          vx *= 1.6;
          vz *= 1.6;
        } else if (e.type === 2) {
          // Sentinel: orta mesafede durup ateş eder
          if (dist > 22) {
            vx *= 1.2;
            vz *= 1.2;
          } else if (dist < 12) {
            vx *= -0.8;
            vz *= -0.8;
          } else {
            vx = 0;
            vz = 0;
          }

          e.fireCooldown -= dt;
          if (e.fireCooldown <= 0 && dist < 50) {
            spawnBullet(dx, dz, false, { x: e.x, z: e.z }, 28);
            e.fireCooldown = 2.2 + Math.random() * 1.4;
          }
        } else if (e.type === 3) {
          // Hopper: zıplayarak yaklaşır
          e.hopTimer -= dt;
          if (e.hopTimer <= 0) {
            const hopStrength = 12;
            const hopDir = normalize2(dx, dz);
            vx = hopDir.x * (e.speed * 2.4);
            vz = hopDir.z * (e.speed * 2.4);
            e.hopTimer = 1.4 + Math.random();
          }
        }

        e.x += vx * dt;
        e.z += vz * dt;

        e.x = clamp(e.x, -WORLD_SIZE / 2 + 3, WORLD_SIZE / 2 - 3);
        e.z = clamp(e.z, -WORLD_SIZE / 2 + 3, WORLD_SIZE / 2 - 3);

        const groundY = terrainHeight(e.x, e.z);
        const baseY = e.type === 2 ? groundY + 1.8 : groundY + 1.4;
        e.mesh.position.set(e.x, baseY, e.z);

        const dPlayer = Math.hypot(player.x - e.x, player.z - e.z);
        if (dPlayer < player.radius + e.radius) {
          player.hp -= e.damage * dt;
          if (player.hp <= 0) {
            player.hp = 0;
            playHit();
            onGameOver();
            return;
          }
        }

        if (e.hp <= 0) {
          killEnemy(i);
        }
      }
    }

    function updateBullets(dt) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx * dt;
        b.z += b.vz * dt;
        b.life -= dt;

        const y = terrainHeight(b.x, b.z) + (b.fromPlayer ? 2.1 : 2);
        b.mesh.position.set(b.x, y, b.z);

        if (
          Math.abs(b.x) > WORLD_SIZE / 2 + 8 ||
          Math.abs(b.z) > WORLD_SIZE / 2 + 8 ||
          b.life <= 0
        ) {
          scene.remove(b.mesh);
          bullets.splice(i, 1);
          continue;
        }

        if (b.fromPlayer) {
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            const d = Math.hypot(e.x - b.x, e.z - b.z);
            if (d < e.radius + b.radius) {
              let dmg = player.damage;
              if (player.critChance && Math.random() < player.critChance) {
                dmg *= 1.8;
              }
              e.hp -= dmg;
              playHit();
              scene.remove(b.mesh);
              bullets.splice(i, 1);
              if (e.hp <= 0) {
                killEnemy(j);
              }
              break;
            }
          }
        } else {
          const d = Math.hypot(player.x - b.x, player.z - b.z);
          if (d < player.radius + b.radius) {
            player.hp -= 14;
            playHit();
            scene.remove(b.mesh);
            bullets.splice(i, 1);
            if (player.hp <= 0) {
              player.hp = 0;
              onGameOver();
            }
          }
        }
      }
    }

    function updateXpOrbs(dt) {
      for (let i = xpOrbs.length - 1; i >= 0; i--) {
        const orb = xpOrbs[i];
        const dx = player.x - orb.x;
        const dz = player.z - orb.z;
        const dist = Math.hypot(dx, dz);

        if (dist < player.pickupRadius) {
          const pull = 12 * dt;
          const n = normalize2(dx, dz);
          orb.x += n.x * pull;
          orb.z += n.z * pull;
          const y = terrainHeight(orb.x, orb.z) + 0.7;
          orb.mesh.position.set(orb.x, y, orb.z);
        }

        if (dist < player.radius + orb.radius) {
          xp += orb.value;
          playPickup();
          scene.remove(orb.mesh);
          xpOrbs.splice(i, 1);

          while (xp >= xpNeeded) {
            xp -= xpNeeded;
            level++;
            xpNeeded = Math.floor(10 + level * 6);
            queueLevelUp();
          }
        }
      }
    }

    function autoShoot(dt) {
      shootCooldown -= dt;
      if (shootCooldown > 0) return;
      if (enemies.length === 0) return;

      let nearest = null;
      let best = Infinity;
      for (const e of enemies) {
        const d = Math.hypot(e.x - player.x, e.z - player.z);
        if (d < best) {
          best = d;
          nearest = e;
        }
      }
      if (!nearest) return;

      spawnBullet(nearest.x - player.x, nearest.z - player.z, true);
      shootCooldown = 1 / player.fireRate;
    }

    function updateHud() {
      hudHp.textContent = `${Math.round(player.hp)} / ${player.maxHp}`;
      hudLevel.textContent = level.toString();
      hudKills.textContent = killCount.toString();
      hudTime.textContent = formatTime(elapsedTime);

      const pct = clamp((xp / xpNeeded) * 100, 0, 100);
      xpFill.style.width = pct + "%";
      xpText.textContent = `XP ${Math.floor(xp)} / ${xpNeeded}`;
    }

    function updateCamera(dt) {
      const distance = 58;
      const height = 40;

      const targetPos = new THREE.Vector3(
        player.x + Math.sin(cameraYaw) * distance,
        player.y + height,
        player.z + Math.cos(cameraYaw) * distance
      );
      camera.position.lerp(targetPos, cameraFollowSmooth);
      camera.lookAt(player.x, player.y + 3, player.z);
    }

    function updateDayNight(dt) {
      dayTime += dt / DAY_LENGTH;
      const phase = dayTime % 1; // 0-1
      const angle = phase * Math.PI * 2;

      const sunY = Math.sin(angle);
      const brightness = clamp(sunY * 0.5 + 0.5, 0, 1);

      const dayColor = new THREE.Color(0x87ceeb);
      const nightColor = new THREE.Color(0x020617);
      const bg = nightColor.clone().lerp(dayColor, brightness);
      scene.background.copy(bg);
      scene.fog.color.copy(nightColor.clone().lerp(dayColor, 0.15 + 0.85 * brightness));

      ambientLight.intensity = 0.3 + 0.7 * brightness;
      sunLight.intensity = 0.2 + 1.4 * brightness;

      sunLight.position.set(
        Math.cos(angle) * 120,
        sunY * 120,
        Math.sin(angle) * 120
      );

      if (starMaterial) {
        starMaterial.opacity = 0.2 + (1 - brightness) * 0.8;
        starMaterial.needsUpdate = true;
      }
    }

    function update(dt) {
      elapsedTime += dt;

      // Çok düşman, ama kolay kesilen
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        const batch = 1 + ((elapsedTime / 40) | 0); // zamanla batch artar
        for (let i = 0; i < batch; i++) spawnEnemy();
        const base = 1.4 - elapsedTime * 0.01;
        spawnTimer = Math.max(0.4, base + Math.random() * 0.5);
      }

      updatePlayer(dt);
      updateEnemies(dt);
      updateBullets(dt);
      updateXpOrbs(dt);
      autoShoot(dt);
      updateHud();
      updateCamera(dt);
    }

    // === LOOP ===
    function loop(now) {
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      updateDayNight(dt);

      if (gameState === "playing" && !isPausedForUpgrade) {
        update(dt);
      }

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    // === GAME STATE ===
    function onGameOver() {
      if (gameState !== "playing") return;
      gameState = "gameover";
      isPausedForUpgrade = false;
      pendingLevelUps = 0;

      statTime.textContent = formatTime(elapsedTime);
      statKills.textContent = killCount.toString();
      statLevel.textContent = level.toString();

      upgradeScreen.classList.remove("visible");
      upgradeScreen.style.display = "none";

      gameoverScreen.style.display = "flex";
      requestAnimationFrame(() => {
        gameoverScreen.classList.add("visible");
      });
    }

    // === INPUT: KEYBOARD ===
    window.addEventListener("keydown", (e) => {
      if (e.code === "KeyW" || e.code === "ArrowUp") keyState.up = true;
      if (e.code === "KeyS" || e.code === "ArrowDown") keyState.down = true;
      if (e.code === "KeyA" || e.code === "ArrowLeft") keyState.left = true;
      if (e.code === "KeyD" || e.code === "ArrowRight") keyState.right = true;

      if (e.code === "Space") {
        e.preventDefault();
        tryJump();
      }
    });

    window.addEventListener("keyup", (e) => {
      if (e.code === "KeyW" || e.code === "ArrowUp") keyState.up = false;
      if (e.code === "KeyS" || e.code === "ArrowDown") keyState.down = false;
      if (e.code === "KeyA" || e.code === "ArrowLeft") keyState.left = false;
      if (e.code === "KeyD" || e.code === "ArrowRight") keyState.right = false;
    });

    // === INPUT: JOYSTICK ===
    function getPos(event, element) {
      const rect = element.getBoundingClientRect();
      const clientX = event.touches ? event.touches[0].clientX : event.clientX;
      const clientY = event.touches ? event.touches[0].clientY : event.clientY;
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function joystickStart(event) {
      event.preventDefault();
      joystickActive = true;
      const rect = joystickBase.getBoundingClientRect();
      joystickCenter.x = rect.width / 2;
      joystickCenter.y = rect.height / 2;
      joystickMove(event);
    }

    function joystickMove(event) {
      if (!joystickActive) return;
      event.preventDefault();
      const pos = getPos(event, joystickBase);
      const dx = pos.x - joystickCenter.x;
      const dy = pos.y - joystickCenter.y;
      const maxDist = joystickBase.clientWidth / 2 - 10;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;

      let nx = dx;
      let ny = dy;
      if (dist > maxDist) {
        const ratio = maxDist / dist;
        nx *= ratio;
        ny *= ratio;
      }

      joystickKnob.style.transform =
        `translate(${nx}px, ${ny}px) translate(-50%, -50%)`;

      const normX = nx / maxDist;
      const normY = ny / maxDist;

      joystickVec.x = normX;
      joystickVec.z = -normY; // joystick yukarı -> ileri
    }

    function joystickEnd(event) {
      event && event.preventDefault();
      joystickActive = false;
      joystickVec.x = 0;
      joystickVec.z = 0;
      joystickKnob.style.transform = "translate(-50%, -50%)";
    }

    joystickBase.addEventListener("pointerdown", joystickStart);
    window.addEventListener("pointermove", joystickMove);
    window.addEventListener("pointerup", joystickEnd);
    window.addEventListener("pointercancel", joystickEnd);

    // === BUTONLAR ===
    soundToggle.addEventListener("change", () => {
      soundEnabled = soundToggle.checked;
      if (soundEnabled && gameState === "playing") {
        initAudio();
      }
    });

    btnStart.addEventListener("click", () => {
      soundEnabled = soundToggle.checked;
      if (soundEnabled) initAudio();

      startScreen.classList.remove("visible");
      setTimeout(() => { startScreen.style.display = "none"; }, 180);

      resetGame();
      gameState = "playing";
    });

    btnRestart.addEventListener("click", () => {
      gameoverScreen.classList.remove("visible");
      setTimeout(() => { gameoverScreen.style.display = "none"; }, 180);
      resetGame();
      gameState = "playing";
    });

    btnQuit.addEventListener("click", () => {
      gameoverScreen.classList.remove("visible");
      setTimeout(() => { gameoverScreen.style.display = "none"; }, 180);
      gameState = "start";
      startScreen.style.display = "flex";
      requestAnimationFrame(() => {
        startScreen.classList.add("visible");
      });
    });

    btnJump.addEventListener("click", () => {
      tryJump();
    });

    // === BAŞLAT ===
    initThree();
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
